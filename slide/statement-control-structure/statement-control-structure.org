#+TITLE: Statement and Control Structure
#+SETUPFILE: ../slide-setup.org

* Arithmetic Expression

** Expression

   - Expression :: A combination of values, variables, and operators.
        The purpose is to /have values/.
   - Statement :: A complete line of code that performs some action.
        The purpose is their /side-effects/.


   #+BEGIN_SRC cpp
int main() {
  int a = 3;
  a + 4;
  ++a;
}
   #+END_SRC

   The distinction is important only for theorist.

** Basics

   In PL's, arithmetic expressions consist of operators, operands,
   parentheses, and function calls.  Operators are special functions.

   #+BEGIN_SRC cpp
int main() {
  int a = 1 + 2;
  int b = operator+(1, 2);  // DOES NOT COMPILE
}
   #+END_SRC

   - Unary function :: takes single operand, e.g., negative sign =-=.
   - Binary function :: takes two operands, e.g., plus, minus.
   - Ternary function :: takes three operands., e.g., =a ? b : c=.

** Notation

   - Infix :: Operators are between operands.  Parentheses surrounding
        groups of operands and operators are necessary.  More
        difficult to parse albeit more natural.  E.g., \(2 + 2\),
        \(3\times3\), \((2 + 2) \times 3\).
   - Prefix :: Operators are before operands.  Fancy name: normal
        Polish notation (NPN).  If the arity of the operators is
        fixed, the result is a syntax lacking parentheses or other
        brackets that can still be parsed without ambiguity.  E.g.,
        \(+ \ 2\ 2\), \(\times +2\ 2\ 3\)
   - Postfix :: Operators are places after operands.  Fancy name:
        reverse Polish notation (RPN).  No parentheses are needed
        either.  E.g., \(n!\), \(3\ 2\ 2+\times\), \(2\ 2 + 3\times\).
        Shunting-yard algorithm converts infix to postfix notation.

** Operator Evaluation Order

   In NPN or RPN, operator evaluation is always /unambiguous/.  Not so
   for infix notation.

   To solve Infix notation ambiguity, two rules in PL are needed
   - operator /precedence/ and
   - operator /associativity/

** Operator Precedence

   Given the following expression

   \[3 + 4 \times 5\]

   - Evaluated from left to right, i.e., \(+\) first, the result
     is 35.
   - Evaluated from right to left, i.e., \(\times\) first, the result
     is 23.


   Mathematicians place operators in a /hierarchy of evaluation
   priorities/ and base the evaluation order of expressions partly on
   this hierarchy.

   - Operator Precedence Rule :: Partially defines the order in which
        the operators of different precedence levels are evaluated.
        The operator precedence rules for expressions are based on the
        hierarchy of operator priorities.

** =C++= Operator Precedence

   http://en.cppreference.com/w/cpp/language/operator_precedence

   Operator with higher precedence is evaluated first.  What if they
   are of same precedence?  E.g., \(2 + 3 + 4\).

** Operator Associativity

   - Operator Associativity Rule :: Partially defines the order in
        which the operators of the same precedence levels are
        evaluated.  This rule is based on /convention/.


   Two possible associativity
   - Left to right.  E.g., \(2 + 3 + 4\) in =C++= is equivalent to
     \((2 + 3) + 4\).
   - Right to left.  E.g., \(2 ** 2 ** 3\) in =Python= is equivalent
     to \(2 ** (2 ** 3)\).

** Associativity in Real World

   Floating point math is /not associative/ due to accuracy.  E.g. the
   non-representability of 0.1 and 0.01 in binary means that \(0.1^2\)
   is neither 0.01 nor the closet representable number.  In single
   precision, 0.1 is represented as

   : 0.100000001490116119384765625 exactly

   Squaring it with single-precision floating-point hardware gives

   : 0.010000000707805156707763671875 exactly

   But the representable number closest to 0.01 is

   : 0.009999999776482582092285156250 exactly

** Non-associativity Example

   Using 7-digit significand decimal arithmetic.

   Given \(a = 1234.567\), \(b = 45.67834\), \(c = 0.0004\).
   The symbol \(\rightarrow\) denotes rounding.

*** \((a + b) + c\)                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

    \[\begin{array}{lrcll}
    & 1234 & . & 567 & a\\ + & 45 & . & 67834 & b\\ \hline & 1280
    & . & 24534 & a + b\\ \rightarrow & 1280 & . & 245\\ + & 0 & . &
    0004 & c\\ \hline & 1280 & . & 2454 & \\ \rightarrow
    & 1280 & . & 245 & \end{array}
    \]


*** \(a + (b + c)\)                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:

    \[\begin{array}{lrcll} & 45 & . & 67834 & b\\ + & 0 & . & 0004 & c
    \\\hline & 45 & . & 67874 & b + c\\\rightarrow & 45 & . & 67874
    &\\ + & 1234 & . & 567 & a\\\hline & 1280 & . & 24574 &
    \\\rightarrow & 1280 & . & 246 & \end{array}\]

** Optimization Based on Associativity

   Compiler may /reassociate expressions/ if possible.

   In GCC, left linearization (switch on by =-O3=) is used.  E.g.,
   \[a + b + c + d + e \rightarrow ((((a + b) + c) + d) + e)\]

   In LLVM, it uses the flag =-reassociate=.  This pass reassociates
   commutative expressions in an order that is designed to promote
   better constant propagation, GCSE, LICM, PRE, etc.

   \[4 + (x + 5) \rightarrow x + (4 + 5)\]

   - Constants has rank 0
   - function parameters rank 1 and
   - other values ranked corresponding to the reverse post-order
     traversal of current function (starting at 2) which effectively
     gives values in deep loops higher rank than values not in loops.

** Operand Evaluation Order

   Mathematically, it does not matter.  For programs, it does.

   #+BEGIN_SRC cpp
int foo(int &a) { return a++; }
int main() {
  int a = 3;
  int b = a + a;           // DOES IT MATTER?
  int c = foo(a) + foo(a); // DOES IT MATTER?
}
   #+END_SRC

   More precisely, it matters only when the evaluation of an operand
   has /side effects/.

** Side Effect

   - Side Effect :: The function (e.g., operator) changes either one
        of its parameters or a global variable.


   #+BEGIN_SRC cpp
int a = 0;

int fun() {
  a = 100;
  return 10;
}

int main() {
  b = a + fun();  // 10 or 110?
}
   #+END_SRC

** =C++= Evaluation Order

   /Almost/ all operands, including function parameters are
   *unspecified*.

   There are two kinds of /optional/ evaluations performed by the
   compiler:

   - value computation, e.g., calculation of the value that is
     returned by the expression.
   - side effect, e.g., access (read or write) an object designated by
     a volatile glvalue, and etc.

** Order

   Since =C++11=, /sequenced-before/ rules are used instead of
   /sequence point/ rules in =C++0x=.

   "sequenced-before", denote as \(\prec\) (precede), is an
   asymmetric, transitive, pair-wise relationship between evaluations
   within the same thread.

   - If \(A\prec B\), then evaluation of \(A\) will be complete before
     evaluation of \(B\) begins and vice versa.
   - If \(A\nprec B\) and \(B\nprec A\), then two possibilities exist:
     - evaluations of A and B are unsequenced
     - they may be performed in any order but may not overlap

** Undefined Behavior

   #+BEGIN_SRC cpp
#include <iostream>
using namespace std;

void f(int a, int b) { }
int main() {
  int i = 0;
  i = ++i + i++;     // undefined behavior
  i = i++ + 1;       // undefined behavior
  i = ++i + 1;       // well-defined in C++11
  ++ ++i;            // well-defined in C++11
  f(++i, ++i);       // undefined behavior
  f(i = -1, i = -2); // undefined behavior
  cout << i << i++;
  int a[3];
  a[i] = i++;
}
   #+END_SRC

** Referential Transparency

   - Referential Transparency :: If any two expressions in the program
        that have the same value can be substituted for one another
        anywhere in the program, without affecting the action of the
        program, the program is said to have referential transparency.


   #+BEGIN_SRC cpp
int foo() {
  return 10;
}

int bar(int a, int b) {
  return a + b;
}

int main() {
  int a = foo() * SIZE;
  bar(++a, ++a);
}
   #+END_SRC

** Operator Overloading

   Consider the following example

   #+BEGIN_SRC cpp
int main() {
  int a = 1, b = 2;
  if (a & b) {  }
  if (& b) { }
}
   #+END_SRC

   How about the following example

   #+BEGIN_SRC cpp
class Mat { };

int main() {
  Mat a, b, c;
  MatAdd(MatAdd(a, b), c);
  a + b + c;
}
   #+END_SRC

* Control Structure

* COMMENT Dummy

#  LocalWords:  SETUPFILE SRC cpp PL's Unary NPN arity Postfix RPN
#  LocalWords:  postfix associativity representability representable
#  LocalWords:  significand rightarrow BMCOL BEAMER env lrcll hline
#  LocalWords:  reassociate GCC linearization LLVM reassociates GCSE
#  LocalWords:  LICM PRE glvalue iostream namespace cout
