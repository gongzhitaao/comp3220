#+TITLE: Subprogram Concept
#+SETUPFILE: ../slide-setup.org

* Introduction

** Introduction

   Tow fundamental abstractions
   - process abstraction and
   - data abstraction.


   What is /process abstraction/?
   #+BEGIN_SRC cpp
int swap(int& a, int& b) {
  int c = a;
  a = b;
  b = c;
}
   #+END_SRC

   Why process abstraction?
   - Memory space efficiency,
   - Less development and maintenance time,
   - Increase readability, and etc.

** General Characteristics

   - Each subprogram has a single entry point.
   - The caller is suspended during the execution of the callee.
   - Control always returns to the caller when callee finishes.

   \pause

   Really??

   \pause

   Not really!!

   - Coroutine has multiple entry points.
   - Multi-threaded functions run in parallel.
   - Callee might abort.

** Terminologies

   #+BEGIN_SRC cpp
int fun_name(int a0, float b0, char c0);

int main() {
  int a1; float b1; char c1;
  fun_name(a1, b1, c1);
  // why a1 corresponds to a0???
}
   #+END_SRC

   - ~a0~, ~b0~ and ~c0~ are /formal parameters/, or /parameters/.
   - ~a1~, ~b1~ and ~c1~ are /actual parameters/, or /arguments/.
   - The collection of number, order and types of formal parameters is
     called /parameter profile/.
   - Parameter profile plus the return type is called /protocol/.

** Positional Parameter

   - Positional Parameter :: In nearly all PL, the correspondence
        between actual and formal parameters is done by /position/.


   #+BEGIN_SRC cpp
int func(int v1, float v2, char v3) { }

int main() {
  func(1, 2.3, 'c');
}
   #+END_SRC

   This is convenient as long as parameter list is /short/.

** Keyword Parameter

   - Keyword Parameter :: The name of the formal parameter to which an
        actual parameter is to be bound is specified with the actual
        parameter in a call.


   #+BEGIN_SRC python
def func(v1, v2, v3):
    pass

func(v1 = 1, v2 = 2.3, v3 = 'c')
   #+END_SRC

   The [[http://www.boost.org/doc/libs/1_60_0/libs/parameter/doc/html/][Boost Parameter Library (BPL)]] supports keyword in =C++=.

** Mixed Usage

   Some PL's support both positional and keyword parameters, e.g.,
   =Python=, =R=, and etc.

   #+BEGIN_SRC R
func <- function(v1, v2, v3) v1 + v2 + v3
func(1, v2 = 3, v3 = 4)
   #+END_SRC

   The only /restriction/ is that after a keyword parameter appears in
   the list, all remaining parameters /must/ be keywords.  Why?

   \pause

   #+BEGIN_SRC R
func(v3 = 4, v1 = 3, v2 = 3)
func(v3 = 4, v3 = 3, v1 = 3, v2 = 3)    # ERROR
   #+END_SRC

** Default Value

   Some PL's allow parameters to have /default values/, e.g.,
   =Python=, =C++=, =R= and etc.

   #+BEGIN_SRC python
def func(v1, v2, v3 = 0):
    print(v1 * 100 + v2 * 10 + v3)

func(1, 2)
func(1, 2, 3)
   #+END_SRC

   Some allow mixing parameters with and without default values.

   #+BEGIN_SRC R
func <- function(v1, v2 = 3, v3) v1 + v2 + v3
func(1, v3 = 4)
func(v3 = 4, v1 = 3, v2 = 3)
   #+END_SRC

** Default Value Cont'd

   Javascript, allows parameters to be =undefined=.

   #+BEGIN_SRC js
function foo(v1, v2, v3) {
  v1 = typeof v1 === 'undefined' ? 0 : v1;
  v2 = typeof v2 === 'undefined' ? 0 : v2;
  v3 = typeof v3 === 'undefined' ? 0 : v3;
  console.log(v1 * 100 + v2 * 10 + v3);
}

foo();
foo(1);
foo(1, 2);
foo(1, 2, 3);
   #+END_SRC

** Variable Number of Parameters

   - Variadic functions :: Functions which take a variable number of
        arguments, e.g., ~std::printf~ in =C++=.  Usually the
        parameter is denoted by an ellipsis (\(\dots\)).


   #+BEGIN_SRC cpp
#include <iostream>
#include <cstdarg>
int add_nums(int count, ...) {
  int result = 0;
  va_list args;
  va_start(args, count);
  for (int i = 0; i < count; ++i)
    result += va_arg(args, int);
  va_end(args);
  return result;
}
int main() {
  std::cout << add_nums(4, 25, 25, 50, 50) << '\n';
}
   #+END_SRC

** Packed Parameters

   In =Python=, we can /pack/ and /unpack/ positional and keyword
   arguments.

   #+BEGIN_SRC python
def func(v1, v2):
    print(10 * v1 + v2)

args = (1, 2)                   # a tuple
func(*args)                     # -> func(1, 2)

kwargs = {'v1': 1, 'v2': 2}     # a dict
func(**kwargs)                  # -> func(v1=1, v2=2)
   #+END_SRC

* Parameter Passing

** Semantic Models

   Formal parameters are characterized by one of three distinct
   semantics models:

   - In Mode :: They can receive data from the actual parameter.
   - Out Mode :: They can transmit data to the actual parameter.
   - Inout Mode :: They can do both.

** Data Transfer

   - Either an /actual value/ is copied back and forth or

     #+BEGIN_SRC cpp
int foo(int v) { }
int main() {
  int a = 3;
  foo(a);
}
     #+END_SRC

   - or an /access path/ is transmitted, e.g., pointers, references.

     #+BEGIN_SRC cpp
int foo(int& v) { }
int main() {
  int a = 3;
  foo(a);
}
     #+END_SRC

** Pass-by-Value

   - Implements /in mode/ semantics.
   - The value of the actual parameter is used to initialize the
     corresponding formal parameter
   - which then acts as a local variable in the subprogram


   It may be implemented by /copy/ or /write-protected access path/.

** Pass-by-Result

   - Implements /out mode/ semantics.
   - No value is transmitted to the subprogram
   - The corresponding formal parameter acts as a local variable and
   - Its value is transmitted back to the actual parameter

** Pass-by-Result Cont'd

   #+BEGIN_SRC js
function foo(a, b) {
  a = 0; b = 1;
}
   #+END_SRC

   - What if actual parameters are literals?
     #+BEGIN_SRC js
foo(3, 3)
     #+END_SRC
   - What if actual parameters collide?
     #+BEGIN_SRC js
var v = 0;
foo(v, v);
     #+END_SRC
   - When to evaluate the address of the actual parameter?
     #+BEGIN_SRC js
var v = [1, 2]; var p = 0;
foo(v[p], p);
     #+END_SRC

** Pass-by-Copy

   AKA Pass-by-Value-Result.

   - Implements /in-out mode/ semantics.
   - A combination of pass-by-value and pass-by-result.

** Pass-by-Reference

   Access path is passed to formal parameters.

   - Access to the formal parameters is slower.
   - Aliasing problem.

** Pass-by-Name

   Literally substitue formal parameters with actual parameters.  In
   =C++=, it is similar to /macro/ and /template/ implements this.

   #+BEGIN_SRC cpp
#define min(x, y) ((x) < (y) ? (x) : (y))
int main() {
  min(3, 4);
  min(3 + 4, 4 + 100);
}
   #+END_SRC

* Generic Subprograms

* First Class Citizen

* Subprogram Overloading

* Closure

* COMMENT Dummy

#  LocalWords:  SETUPFILE SRC cpp callee Coroutine Multi func BPL js
#  LocalWords:  PL's Cont'd Javascript typeof Variadic iostream nums
#  LocalWords:  cstdarg va args arg tuple kwargs Inout
