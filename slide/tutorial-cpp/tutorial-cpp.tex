% Created 2016-01-08 Fri 12:19
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}
\usepackage{minted}
\usepackage{svg}
\usepackage[backend=biber,style=alphabetic]{biblatex}
\fvset{fontsize=\footnotesize}
\fvset{frame=lines}
\fvset{framesep=5pt}
\DeclareUnicodeCharacter{200B}{}
\addbibresource{~/Documents/comp3220/master/comp3220.bib}
\AtBeginSection[]{\begin{frame}<beamer>\frametitle{Content}\tableofcontents[currentsection]\end{frame}}
\usetheme{default}
\author{Zhitao Gong}
\date{2016 Spring}
\title{Tutorial -- \texttt{C++}}
\subtitle{COMP3220 -- Principle of Programming Languages}
\hypersetup{
      pdfauthor={Zhitao Gong},
      pdftitle={Tutorial -- \texttt{C++}},
      pdfkeywords={},
      pdfsubject={},
      pdfcreator={Emacs 24.5.1 (Org mode 8.3.2)},
      pdflang={English},
      bookmarks=true,
      unicode=true,
      pdftoolbar=true,
      pdfmenubar=true,
      pdffitwindow=false,
      pdfstartview={FitW},
      pdfnewwindow=true,
      colorlinks=true,
      linkcolor=red,
      citecolor=green,
      filecolor=magenta,
      urlcolor=cyan}
\begin{document}

\maketitle
\begin{frame}{Outline}
\setcounter{tocdepth}{2}
\tableofcontents
\end{frame}


\section{Get Started}
\label{sec:orgheadline12}

\begin{frame}[label={sec:orgheadline1}]{Good Program}
The greatest obstacle to learning to write good programs is a firm
belief that (by Bjarne Stroustrup)

\begin{itemize}
\item it is among the most difficult of technical skills
\item it is a skill that requires some rare talent
\item it is done by socially inept young men in total isolation, mostly
by night
\item it is mostly about building violent video games
\item it is a skill that requires mastery of advanced mathematics
\item it is an activity completely different from everyday ways of
thinking
\item it is something that doesn't help people
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline2}]{Hello World!}
 \begin{itemize}
\item Enter the source code with your favorite editor (Emacs for me)
and save to file \texttt{hello.cpp}.

\begin{minted}[]{cpp}
// my first C++ program
#include <iostream>
using namespace std;

int main() {
  cout << "Hello World!" << endl;
}
\end{minted}

\item Fire up the command line, compile with \texttt{g++ hello.cpp}.  An
executable named \texttt{a.out} appears in the same directory.  Run it
with \texttt{./a.out}.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline3}]{Hello World! -- Line 0}
 \begin{minted}[]{cpp}
// my first C++ program
\end{minted}

Comments are stripped by \emph{cpp} (c preprocessor).

\begin{itemize}
\item Line comment.  Start with \texttt{//}, everything after it is ignored.

\begin{minted}[]{cpp}
// comment
int main() {                    // comment
}
\end{minted}

\item Block comment.  Start with \texttt{/*} and end with \texttt{*/}.  Nested
comment is not allowed.  Everything in between is ignored.

\begin{minted}[]{cpp}
/* comment */
int main(/* comment */) { /* comment */
}
\end{minted}
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline4}]{Hello World! -- Line 1}
 \begin{minted}[]{cpp}
#include <iostream>
\end{minted}

Preprocessor directives precede by a hash sign \texttt{\#}.  They are
interpreted by the preprocessor. This line

\begin{itemize}
\item Search for the file \texttt{iostream} in standard search path, if not
specified otherwise (with \texttt{-I}).

\begin{verbatim}
/usr/local/include
libdir/gcc/target/version/include
/usr/target/include
/usr/include
\end{verbatim}

\item If found, copy everything to current file.  Otherwise error.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline5}]{Hello World! -- Line 2}
 \begin{minted}[]{cpp}
using namespace std;
\end{minted}

Everything declared in name space \texttt{std} is available, e.g., \texttt{cout}
which is declared in \texttt{iostream}.

\begin{minted}[]{cpp}
namespace std {
  // ...
  ostream cout;
  // ...
}
\end{minted}

\texttt{namespace} is used to prevent name collision and global namespace
polluting.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline6}]{Hello World! -- Line 3}
 \begin{minted}[]{cpp}
// empty line
\end{minted}

Spaces are allowed in \texttt{C++} anywhere between basic units.
Different styles require different spaces for indentation, spaces
around function names, etc.  E.g., K\&R, Stroustrup Style, Google
C++ Style Guide and etc.

The International Obfuscated C Code Contest (IOCCC) is a good
example of space usage.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline7}]{Hello World! -- Line 4}
 \begin{minted}[]{cpp}
int main()
\end{minted}

This line initiates the declaration of a function.  Essentially,
their definition is introduced with a succession of
\begin{itemize}
\item a return type, e.g., \texttt{int},
\item a function name, e.g., \texttt{main}, and
\item a pair of parentheses \texttt{()}, optionally including parameters.
\end{itemize}


\texttt{main} function is the \emph{entry point}.  At most one definition is
allowed.  No \texttt{main} function in libraries.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline8}]{Hello World! -- Line 4 \& 6}
 \begin{minted}[]{cpp}
{}
\end{minted}

\begin{itemize}
\item The brace at line 5 \texttt{\{} indicates the beginning of the main
function and \texttt{\}} the end of it.
\item Everything between brace pair is the \emph{body} of the function.
\item Brace pair is used to delimit \emph{scope} in \texttt{C++}.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline9}]{Hello World! -- Line 5}
 \begin{minted}[]{cpp}
cout << "Hello World!" << endl;
\end{minted}

This line is a \texttt{C++} statement.  Usually they are executed in the
same order they appear unless Level 3 optimization (\texttt{-O3})is on.

\begin{itemize}
\item \texttt{cout} is character/console output.
\item \texttt{<<} is insertion operator.  Insert what follows into the output,
i.e. print to the console.
\item The statement ends with \alert{SEMICOLON (\texttt{;})}.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline10}]{Environment}
 \begin{description}
\item[{Platform}] By default I recommend *nix OS, choose whatever
distribution you like, e.g. Ubuntu, CentOS.
\begin{itemize}
\item Linux machine in Computer Lab and Davis Hall 123.  You may SSH
to machines in Davis Hall 123.
\item Otherwise, do the configuration yourself.
\end{itemize}
\item[{IDE}] Integrated Development Environment, e.g., Visual Studio,
CodeBlocks, Eclipse and etc., is not recommended for
programming assignment.
\item[{Compiler}] I use \texttt{g++ 5.2.1} for \texttt{C++}.  So feel free to use any
of the \texttt{C++11} features in the programming assignment.
\end{description}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline11}]{General}
 The ISO \texttt{C++} standard defines two kinds of entities:
\begin{itemize}
\item \emph{Core language features}, such as built-in types (e.g., \texttt{char} and
\texttt{int}) and loops (e.g., \texttt{for}-statements and \texttt{while}-statements)
\item \emph{Standard-library components} (in namespace \texttt{std}), such as
containers (e.g., \texttt{vector} and \texttt{map}) and I/O operations (e.g.,
\texttt{<<} and \texttt{getline()}).

The standard-library components are perfectly ordinary \texttt{C++} code
provided by \emph{every} \texttt{C++} implementation.
\end{itemize}
\end{frame}


\section{\texttt{C++} Basics}
\label{sec:orgheadline32}

\begin{frame}[fragile,label={sec:orgheadline13}]{Variable}
 Fundamental types include

\begin{description}
\item[{Character}] Represents a single character, e.g., \texttt{char}.
\item[{Numeric integer}] Stores \emph{exact} integer value.  They vary in
signedness and size, e.g., \texttt{int}, \texttt{long long}.
\item[{Floating-point}] Represent real values, such as 3.14 or 0.01,
with different levels of precision, e.g., \texttt{float}, \texttt{double}.
\item[{Boolean}] Represent one of two states. e.g., \texttt{bool}.
\end{description}


\texttt{C++} standard library (STL) provides extension such as
\texttt{std::string}, \texttt{std::iterator} and etc.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline14}]{Literals}
 Literals are constants refer to fixed values that the program may
not alter.

\begin{itemize}
\item Integers.  E.g., 212 \texttt{signed int} in decimal, 215u \texttt{unsigned
     int} in decimal, 0xFEEL \texttt{signed long} in hexadecimal, 066
\texttt{signed int} in octal.
\item Floating points.  E.g., 3.1415, 3.1e-2, 1.f (note the dot in
between).
\item Boolean literals, \texttt{true} and \texttt{false}.  0 is \texttt{false} and all
others are \texttt{true}.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline15}]{Arithmetic}
 These are the basic arithmetic operators in \texttt{C++}.

\begin{minted}[]{cpp}
int main() {
  int x = 3, y = 4;
  x + y;                        // plus
  +x;                           // unary plus
  x - y;                        // minus
  -x;                           // unary minus
  x * y;                        // multiply
  x / y;                        // divide
  x % y;                        // remainder (modulus, integer only)
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline16}]{Comparison}
 These are the basic comparison operators.

\begin{minted}[]{cpp}
int main() {
  int x = 4, y = 3;
  x == y;                       // equal (BE CAREFUL for float)
  x != y;                       // not equal
  x < y;                        // less than
  x > y;                        // greater than
  x <= y;                       // less than or equal
  x >= y;                       // greater than or equal
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline17}]{Logic}
 Logic operators include

\begin{minted}[]{cpp}
int main() {
  int x = 3, y = 1;
  x & y;                        // bitwise AND
  x | y;                        // bitwise OR
  x ^ y;                        // bitwise XOR
  ~x;                           // bitwise complement
  x && y;                       // logic AND
  x || y;                       // logic OR
}
\end{minted}

\begin{itemize}
\item A bitwise logical operator yields a result of their operand type
for which the operation has been performed on each bit.
\item The logical operators \texttt{\&\&} and \texttt{||} simply return \texttt{true} or
\texttt{false} depending on the values of their operands.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline18}]{Assignment}
 \begin{minted}[]{cpp}
int main() {
  int a = 5;                    // OK, a lvalue, 5 rvalue
  a + 3 = 4;                    // WRONG, a + 3 rvalue
  int a = 5.243;                // narrowing conversion
}
\end{minted}

\begin{description}
\item[{L-value}] Expressions that refer to a memory location,
potentially allowing new values to be assigned.  An lvalue may
appear as either the left-hand or right-hand side of an
assignment.
\item[{R-value}] That are not L-values.  They may appear only on the
right hand side of the assignment.
\end{description}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline19}]{Conversion}
 \texttt{C++} performs all \emph{meaningful conversions} between the basic types
so that they can be mixed freely.

\begin{description}
\item[{Usual Arithmetic Conversions}] Conversions used in expressions
aim to ensure that expressions are computed at the \emph{highest
precision} of its operands.
\end{description}


\begin{minted}[]{cpp}
int main() {
  int x = 3;
  double b = 4;
  char c = 'a';
  x + b;                        // x is converted to double
  c + x;                        // c is converted to int
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline20}]{Variable Initialization}
 \begin{itemize}
\item Don't introduce a name until you have a suitable value for it.
\item \texttt{=}-form is traditional and dates back to \texttt{C}.  If in doubt, use
the general \texttt{\{\}}-list form, which saves you from conversions that
lose information, i.e., narrowing conversion.
\item Types may be deduced from the initializer.
\end{itemize}

\begin{minted}[]{cpp}
int main () {
  int a = 5;          // initial value: 5
  int b(3);           // initial value: 3
  int c{2};           // initial value: 2
  int result;         // initial value undetermined
  auto d = a;         // d is integer 5, deduced type: int
  decltype(c) e;      // integer value undetermined

  int e{7.2};         // ERROR, narrowing conversion
  double f{'a'};      // OK
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline21}]{Shorthand Operators}
 \texttt{C++} provides concise and convenient shorthand operators to modify
variables.  All arithmetic and bitwise logic operators may be
combined with \texttt{=}.

\begin{minted}[]{cpp}
int main() {
  int x = 4, y = 3;
  x += y;                       // x = x + y;
  ++x;                          // x = x + 1; use x;
  x++;                          // use x; x = x + 1;
  --x;                          // x = x - 1; use x;
  x--;                          // use x; x = x - 1;
  x *= y;                       // x = x * y;
  x |= y;                       // x = x | y;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline22}]{Variable Scope}
 Like most PL's, \texttt{C++} uses \emph{lexical scoping} or \emph{static scoping}.
A declaration introduces its name into a scope.

\begin{description}
\item[{Local Scope}] \emph{Local Name} is declared in a function or lambda.
Scope extends from the point of declaration to the end of the
block where it is declared.
\item[{Class Scope}] \emph{Member name} (class member name) is defined in a
class outside any function, lambda, or enum class.  Scope
extends from the opening \texttt{\{} of its enclosing declaration to
the end of that declaration.
\item[{Namespace Scope}] \emph{Namespace member name} is defined in a
namespace outside any function, lambda, class, or enum class.
Scope extends from the point of declaration to the end of its
namespace.
\end{description}


A name not declared inside any other construct is called a global
name and is said to be in the global namespace.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline23}]{Variable Scope Example}
 An object \emph{must} be constructed/initialized before it is used and
will be destroyed at the end of its scope.

\begin{minted}[]{cpp}
struct foo {
  int count;                    // member name
};

int g = 4;                      // global

int main(int argc) {            // main is global, argc is local
  int a = 3;                    // local, visible in main
  {
    int b = 4;                  // local visible inside {}
  }
  int g = 3;                    // local g, shadows global g
  ::g = 40;                     // refer to global g
  c = 4;                        // ERROR!!
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline24}]{Constants}
 \begin{description}
\item[{\texttt{const}}] "I promise not to change this value".  Primarily used
to specify interfaces.
\item[{\texttt{constexpr}}] "To be evaluated at compile time".  Used primarily
to specify constants, to allow placement of data in read-only
memory.
\end{description}


\begin{minted}[]{cpp}
constexpr int square(int n) { return n * n; }

int main() {
  const int a = 3;              // a is named constant
  int b = 3;                    // b is not constant

  constexpr int c = 1.4 * square(a); // OK
  constexpr int d = 1.4 * square(b); // ERROR
  const int e = 1.4 * square(b);     // OK
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline25}]{Array}
 \begin{minted}[]{cpp}
int main() {
  int a[3]{1,2,3};           // array of 3 integers
  char b[4];                 // array of 4 characters
  int size = 10;
  int b[size] = {1,2,3};     // runtime-sized array c++14
  int c[3][4];
}
\end{minted}

\begin{itemize}
\item In declarations, \texttt{[ ]} means "array of".
\item All array are 0-based.  So \texttt{a[0]} is the first element and \texttt{a[2]}
     is the last element.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline26}]{Multi-Dimensional Array}
 In memory, milti-dimensional array is actually a long 1D array, in
stored row-major order.

\begin{columns}
\begin{column}{0.5\columnwidth}
\begin{block}{Syntax Sugar}
\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main () {
  const int W = 3;
  const int H = 2;
  int a[H][W] = {1, 2, 3, 4, 5, 6};

  for (int i = 0; i < H; ++i)
    for (int j = 0; j < W; ++j)
      cout << a[i][j] << endl;
}
\end{minted}
\end{block}
\end{column}

\begin{column}{0.5\columnwidth}
\begin{block}{Pseudo Multi-Dimensional}
\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main () {
  const int W = 3;
  const int H = 2;
  int a[H * W]{1, 2, 3, 4, 5, 6};

  for (int i = 0; i < H; ++i)
    for (int j = 0; j < W; ++j)
      cout << a[i * W + j] << endl;
}
\end{minted}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline27}]{Character Array}
 Strings in \texttt{C/C++} are represented by \texttt{char} array.  By convention,
\emph{null character}, '\texttt{\textbackslash{}0}', is used as terminator, signaling the end
of string.

\begin{minted}[]{cpp}
#include <iostream>
#include <cstdio>
int main() {
  char foo[10] = "1234";
  std::cout << foo << std::endl;
  char bar[10] = "1234\0abcd";
  printf("%s\n", bar);
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline28}]{Pointer}
 \begin{itemize}
\item Pointer type stores the \emph{address} of memory location, Pointer may
change its value, i.e., point to another memory location.
\item Reference type is \emph{auto de-referenced} pointer.  But its memory
address may not change.
\end{itemize}

\begin{minted}[]{cpp}
int main() {
  int a = 3;
  int* b = &a;
  int& c = a;
  // a, b, c share a memory location
  (*b) = 4;
  c = 40;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline29}]{Pointer Cont'd}
 Prefix unary \texttt{*} means "contents of", and prefix unary \texttt{\&} means
"address of".  In declarations, operators (such as \texttt{\&} , \texttt{*} and
\texttt{[]}) are called \emph{declarator operators}.


\begin{itemize}
\item When we don't have an object to point to or
\item if we need to represent the notion of "no object available"
(e.g., for an end of a list)
\end{itemize}

The pointer is set the value \texttt{nullptr} ("the null pointer").  There
is only one \texttt{nullptr} shared by all pointer types.

\begin{minted}[]{cpp}
int main() {
  int* a = nullptr;
  double* b = nullptr;
  int x = nullptr;              // ERROR
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline30}]{Null Pointer}
 In old code, 0 or \texttt{NULL} is typically used.  However, using
\texttt{nullptr} eliminates potential confusion between integers, e.g., 0
or \texttt{NULL}, and pointers, e.g., \texttt{nullptr} which is of type
\texttt{std::nullptr\_t}.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main() {
  cout << (0 == nullptr) << endl;
  cout << (NULL == nullptr) << endl;
  cout << (0 == NULL) << endl;

  int a = NULL;                 // warning
  int x = nullptr;              // ERROR
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline31}]{Dynamic Memory}
 \begin{itemize}
\item Allocating memory on heap with \texttt{new}.
\begin{itemize}
\item allocating blocks of memory and
\item invoking constructor.
\end{itemize}
\item De-allocating memory with \texttt{delete}.
\begin{itemize}
\item invoking destructor and
\item returning memory to system.
\end{itemize}
\end{itemize}

\begin{minted}[]{cpp}
int main() {
  int* arr;
  arr = new int [10];
  delete[] arr;

  int* val;
  val = new int (3);
  delete val;
}
\end{minted}
\end{frame}

\section{Control Structure}
\label{sec:orgheadline39}

\begin{frame}[fragile,label={sec:orgheadline33}]{Conditional Branch \texttt{if else}}
 The condition is not necessary Boolean type.  It may also be types
that could be \emph{implicitly} cast to Boolean, e.g., char, integer and
etc.  If no curly bracket, only the first statement block belongs
to \texttt{if}.

\begin{minted}[]{cpp}
int main() {
  int a = 0;
  if (a) a = 100;
  else if (3 == a) a = 4;

  if (a)
    a -= 1;
  a -= 1;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline34}]{Conditional Branch \texttt{switch case}}
 The condition is expected to be integer-compatible.

\begin{minted}[]{cpp}
int main() {
  int a = 2;
  switch (a) {
  case 1: { a -= 1; break; }
  case 2: a -= 2; /* missing break */
  case 3: a -= 3; break;
  default: a -= 0;
  }
}
\end{minted}

Remember the \texttt{break} statement at the end of every \texttt{case} unless
intended otherwise.  Curly bracket for each \texttt{case} body is
optional.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline35}]{Unconditional Branch \texttt{goto}}
 Avoid \texttt{goto}.  The only useful case I know is deeply nested loop.

\begin{minted}[]{cpp}
int main() {
  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < i; ++j) {
      for (int k = 0; k < 100; ++k)
        if (5 == k) goto end;
    }
  }

 end:
  ;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline36}]{Loop \texttt{for}}
 \begin{itemize}
\item Initial expression is evaluated \alert{once before} the loop.
\item Termination condition is evaluated \alert{before} every loop.
\item Iteration expression is evaluated \alert{after} every loop.
\end{itemize}


\begin{minted}[]{cpp}
int main() {
  int b = 10;
  for (int i = 0; i < b; ++i) {
    b -= 2;
    int c;   // visible only inside for
  }
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline37}]{Loop Range \texttt{for}}
 Since \texttt{C++11}, a new \texttt{for} loop syntax is available.

\begin{minted}[]{cpp}
#include <iostream>

int main() {
  int a[3]{1, 2, 3};
  for (int i : a) {
    std::cout << i << std::endl;
  }
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline38}]{Loop \texttt{while}}
 The two loop structures are equivalent:
\begin{itemize}
\item \texttt{while(cond) \{ \}}
\item \texttt{for(; cond; ) \{ \}}
\end{itemize}

\begin{minted}[]{cpp}
int main() {
  int a = 3;
  while (a > 0) --a;

  int b = 4;
  do {
    --b;
  } while (b > 0);

  int c = 4;
  while (--c > 0) /* empty */ ;
}
\end{minted}
\end{frame}

\section{Function}
\label{sec:orgheadline52}

\begin{frame}[fragile,label={sec:orgheadline40}]{Function}
 Function consists of return type, function name, argument list and
function body.

\begin{minted}[]{cpp}
int foo(int a, int b = 3) {
  return a + b;
}
int bar(int a, int b = 3, int c) { // WRONG
  return 0;
}
int fun();
int main() {
  int b = foo(3);
  int c = foo(3, 4);
  fun();
}
int fun() { }
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline41}]{Function Side Effect}
 \texttt{C++} allows functions to have \emph{side effects}.

\begin{minted}[]{cpp}
#include <iostream>
int f0(int a) { a -= 1; return a; }
int f1(int& a) { a -= 1; return a; }
int f2(int* a) { *a -= 1; return a; }

int main() {
  int a = 3;
  f0(a);     // value of a?
  f1(a);     // value of a?
  f2(&a);    // value of a?
  std::cout << f1(a) << std::endl;
  std::cout << a << std::endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline42}]{Lambda Function}
 It is introduced in \texttt{C++11}.
\begin{description}
\item[{Lambda function}] Constructs a closure: an unnamed function
object capable of capturing variables in scope.
\end{description}

\begin{minted}[]{cpp}
#include <functional>
#include <iostream>
int main() {
  int a = 10;
  std::function<int(int)> func = [&](int p) { return (a += p); };
  std::cout << func(33) << std::endl;
  std::cout << a << std::endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline43}]{Overloading}
 Tow different functions may have the same name if their parameter
are different
\begin{itemize}
\item different number of parameters, or
\item any of their parameters are of a different type.
\end{itemize}

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int add(int a, int b) { return a + b; }
float add(float a, int b) { return a + b; }

int main() {
  cout << add(3, 4) << endl;
  cout << add(2.3f, 4) << endl;
  cout << add(2.3, 4) << endl;  // ERROR, ambiguous
  cout << add(2.3, 3.4) << endl; // ERROR, ambiguous
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline44}]{Preprocessor Directives}
 \begin{itemize}
\item Preprocessor directives are lines preceded by a hash sign \texttt{\#}.
\item The preprocessor process these directives \alert{before} compilation.
\item Backslash \texttt{\textbackslash{}} may be used to extend a directive to multiline.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline45}]{Directives -- Macro}
 \texttt{\#define} and \texttt{\#undef}.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

#define SIZE 3
#define max(a, b) (a) > (b) ? (a) : (b)
#define str(x) #x
#define glue(a,b) a ## b

int main() {
  int v[SIZE];
  max(3, 4);
#undef SIZE
  char m[SIZE];                 // ERROR

  glue(c, out) << str(Hello\nWor
              ld!) << endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline46}]{Directives -- Conditional Inclusion}
 \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#if}, \texttt{\#endif}, \texttt{\#else} and \texttt{\#elif}.

\begin{minted}[]{cpp}
int main() {
#ifdef SIZE
  int v[SIZE];
#else
  int v[10];
#endif
}
\end{minted}

is equivalent to

\begin{minted}[]{cpp}
int main() {
  int v[10];
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline47}]{Directive -- Line Control}
 \begin{minted}[]{cpp}
int main() {
#line 11 "Test Message"
  int 3a;
}
\end{minted}

Generates error message

\begin{verbatim}
Test Message: In function ‘int main()’:
Test Message:11:7: error: ...
\end{verbatim}

Without \texttt{\#line}

\begin{verbatim}
test.cpp: In function ‘int main()’:
test.cpp:3:7: error: ...
\end{verbatim}

You don't actually need to set this directive manually.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline48}]{Directive -- Error}
 \begin{minted}[]{cpp}
#if __cplusplus > 10
#error A C++ compiler is required!
#endif

int main() {
  int a;
}
\end{minted}

This directive aborts the compilation process when it is found,
generating a compilation error that can be specified as its
parameter.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline49}]{Directive -- Inclusion}
 \begin{minted}[]{cpp}
#include <iostream>
#include "header.h"

int main() { }
\end{minted}

\begin{itemize}
\item The first header, between angle-brakets, is system wide header
files, i.e., those in system search path.
\item The second header, between double quotes, is searched locally
then system wide if failed.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline50}]{Directive -- Pragma}
 This directive is used to specify diverse options to the compiler.
Compiler \emph{silently} ignores this directive if no support.

\begin{minted}[]{cpp}
#ifndef FOO_H_
#define FOO_H_

#prama once                     // include only once

class Foo { };

#endif /* FOO_H_ */
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline51}]{Predefined Macros}
 The following macros are set by the compilers.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main() {
  cout << __LINE__ << endl
       << __FILE__ << endl
       << __DATE__ << endl
       << __TIME__ << endl
       << __cplusplus << endl;
}
\end{minted}
\end{frame}

\section{User-Defined Types}
\label{sec:orgheadline59}

\begin{frame}[fragile,label={sec:orgheadline53}]{Enumeration}
 \begin{minted}[]{cpp}
int main() {
  enum class Color {Red, Yellow, Green};
  enum class TrafficLight {Red, Yellow, Green};

  Color color = Color::Red;
  TrafficLight tl = TrafficLight::Red;
}
\end{minted}

Enumerators, e.g., \texttt{Red}, resides in the scope of their \texttt{enum
   class}.  \texttt{Color::Red} is different from \texttt{TrafficLight::Red}.

Primarily used to make code more readable and less error-prone.

By default, the integer values of enumerators starts with 0 and
increases by one for each additional enumerator.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline54}]{\texttt{enum class} vs \texttt{enum}}
 \texttt{enum class} is strongly typed.

\begin{minted}[]{cpp}
int main() {
  enum class Color1 {Red, Yellow, Green};
  enum class Color2 {Red, Yellow, Green};
  enum       Color3 {Red, Yellow, Green};

  Color1 x = Red;               // ERROR
  Color1 y = Color2::Red;       // ERROR
  Color1 z = 2;                 // ERROR
  Color3 a = 2;                 // ERROR
  int i = Color1::Red;          // ERROR
  int j = Color3::Red;          // OK
  int k = Red;                  // OK, Color3::Red
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline55}]{\texttt{enum class} Operation}
 By default, \texttt{enum class} supports assignment, initialization and
comparisons.  Additional operation may be defined.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;
enum class Color {Red, Yellow, Green};
Color& operator++(Color& t) {
  switch (t) {
  case Color::Green: return t = Color::Yellow;
  case Color::Yellow: return t = Color::Red;
  case Color::Red: return t = Color::Green;
  }
}
int main() {
  Color c = Color::Red;
  cout << static_cast<std::underlying_type<Color>::type>(c) << endl;
}
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgheadline56}]{Structures}
\begin{itemize}
\item General syntax for declaration and intialization
\item Main usage, i.e., collect data
\item Access fields
\end{itemize}

See the accompany code and comments.
\end{frame}

\begin{frame}[label={sec:orgheadline57}]{Unions}
\begin{description}
\item[{Union}] A struct in which all members are allocated at the same
address so that the it occupies only as much space as its
largest member.  The most recent written member is \emph{active}.
Only one member is active at a time.
\end{description}


It's \emph{undefined behavior} to read from the member of the union that
wasn't most recently written.  Many compilers implement, as a
non-standard language extension, the ability to read inactive
members of a union.
\end{frame}

\begin{frame}[label={sec:orgheadline58}]{Classes}
\begin{itemize}
\item Basic syntax for declaration and definition
\item Techniques and concepts, e.g., abstract/concrete class,
inheritance, interface, etc.
\item Operator overloading
\item Separate compiling, modularity

\item Demo Complex Class
\end{itemize}
\end{frame}

\section{Standard Library}
\label{sec:orgheadline80}

\begin{frame}[fragile,label={sec:orgheadline60}]{Standard Library Components}
 \begin{itemize}
\item run-time language support, e.g., for allocation and run-time type
information.
\item The C standard library, e.g., \texttt{cstdio}, \texttt{cmath}.
\item strings, support for international character sets and
localization
\item regular expression
\item I/O streams
\item a framework of containers, e.g., \texttt{vector}, \texttt{map} and algorithms,
e.g., \texttt{find()}, \texttt{sort()}.
\item support for numeric computation
\item support for concurrent programming
\item support for template metaprogramming
\item smart pointer
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline61}]{Use Standard Library}
 Every standard library is provided through some standard header.

\begin{minted}[]{cpp}
#include <vector>               // vetor container
#include <string>               // string support

int main() {
  std::vector<int> v0{1, 2, 3};
  std::vector<std::string> v1{"string", "string"};
}
\end{minted}

The standard library is defined in a namespace called \texttt{std}.  To
use standard library utilities, the \texttt{std::} prefix can be used.

It is generally in poor taste to dump every name from a namespace
into the global namespace.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline62}]{Old \texttt{C} Standard Library}
 Headers from the \texttt{C} standard library, such as \texttt{<stdlib.h>} are
provided, albeit discouraged.

For each such header there is also a version with its name prefixed
by \texttt{c} and the \texttt{.h} removed.

\begin{verbatim}
<stdio.h>  => <cstdio>
<stdlib.h> => <cstdlib>
\end{verbatim}

This version places its declarations in the \texttt{std} namespace.

\begin{minted}[]{cpp}
#include <cmath>

int main() {
  std::sqrt(3);
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline63}]{Strings}
 STL \texttt{<string>} provides common string operations.

\begin{minted}[]{cpp}
#include <iostream>
#include <string>
using namespace std;

int main() {
  string s{"12345678"};
  cout << s.substr(1, 3) << endl;

  s.replace(0, 1, "abcd");
  cout << s << endl;

  cout << s + "hello" << endl;
  cout << s.c_str() << endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline64}]{Regular Expression}
 STL \texttt{<regex>} provides regular expression support.

\begin{minted}[]{cpp}
#include <regex>
#include <iostream>
using namespace std;

int main() {
  regex pat{"\\(\\d{3}\\) \\d{3}-\\d{4}"};
  if (regex_match("(334) 333-0610", pat))
    cout << "Match" << endl;

  pat = R"(\b(sub)([^ ]*))";
  string s{"this subject has a submarine as a subsequence"};
  for (sregex_iterator i(s.begin(), s.end(), pat);
       i != sregex_iterator{}; ++i)
    cout << i->str() << endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline65}]{I/O Streams}
 The I/O stream library provides formatted and unformatted buffered
I/O of text and numeric values.

\begin{itemize}
\item \texttt{ostream} converts typed objects to a stream of characters bytes.
\item \texttt{istream} converts a stream of characters bytes to typed objects.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline66}]{Output}
 In \texttt{<ostream>} , the I/O stream library defines output for every
built-in type.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main() {
  cout << 3 << 3.3 << 'a' << "hello" << bool << endl;
}
\end{minted}

The operator \texttt{<<}, i.e., "put to", is used as an output operator on
objects of type ostream.  By overloading this operator, we can
serialize user-defined objects.

Predefined \texttt{ostream} objects:
\begin{itemize}
\item \texttt{cout} standard output stream, connects to \texttt{stdout}.
\item \texttt{cerr} standard stream to report errors, connects to \texttt{stderr}.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline67}]{Input}
 In \texttt{<istream>} , the I/O stream library defines input for every
built-in type.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main() {
  int a;
  double b;
  char c;
  cin >> a >> b >> c;
}
\end{minted}

The operator \texttt{>>}, i.e., "get from", is used as an input operator.
By default, a whitespace character, e.g., a space or a newline,
delimits one read.  \texttt{getline()} is used get a whole line,
\emph{including} the terminating newline character.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline68}]{I/O State}
 An iostream has a state that we can examine to determine whether an
operation succeeded.

\begin{minted}[]{cpp}
#include <iostream>
using namespace std;

int main() {
  int i;
  while (cin >> i) {
    cout << i << endl;
  }
}
\end{minted}

In general, the I/O state holds all the information needed to read
or write, such as formatting information, error state (e.g.,
end-of-file), and what kind of buffering is used.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline69}]{I/O of User-Defined Type}
 \begin{minted}[]{cpp}
#include <iostream>
using namespace std;
struct Point {
  int x, y;
};
ostream& operator<<(ostream& os, const Point& p) {
  os << '(' << p.x << ',' << p.y << ')';
}
istream& operator>>(istream& is, Point& p) {
  is >> p.x >> p.y;
}
int main() {
  Point p;
  cin >> p;
  cout << p << endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline70}]{File Stream}
 In \texttt{<fstream>} , the STL provides streams to and from a file:
\begin{description}
\item[{\texttt{ifstream}}] read from a file
\item[{\texttt{ofstream}}] write to a file
\item[{\texttt{fstream}}] two way stream, both read from and write to a file
\end{description}


\begin{minted}[]{cpp}
#include <fstream>
using namespace std;

int main() {
  ofstream out("file.txt");
  ifstream in("file.txt");
}
\end{minted}

The usage of \texttt{ofstream} and \texttt{ifstream} is same as \texttt{cout} and \texttt{cin}.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline71}]{String Stream}
 In \texttt{<sstream>}, the STL provides streams to and from a string:
\begin{description}
\item[{\texttt{istringstream}}] read from a string
\item[{\texttt{ostringstream}}] write to a string
\item[{\texttt{stringstream}}] read from and write to a string
\end{description}


\begin{minted}[]{cpp}
#include <sstream>
#include <iostream>
using namespace std;
int main() {
  stringstream s;
  s << 3 << 'a' << "abd";
  cout << s.str() << endl;
  int a;
  char b;
  string c;
  s >> a >> b >> c;
  cout << a << b << c << endl;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline72}]{Stream Consideration}
 \begin{enumerate}
\item Streams are are \emph{type-safe}, \emph{type-sensitive}, and \emph{extensible}
\item It is, however, horribly \emph{slow}.
\item Not fast and succinct as \texttt{printf} and \texttt{sprintf}.

\begin{minted}[]{cpp}
#include <cstdio>   // printf
#include <iostream> // cout
#include <iomanip>  // setprecision, fixed
using namespace std;

int main() {
  cout << setprecision(2) << fixed << 1.23456 << "\n";
  printf("%.2f\n", 1.23456);
}
\end{minted}
\end{enumerate}


Personally, I would fall back to \texttt{printf} and \texttt{sprintf} whenever
possible.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline73}]{Containers}
 Various data structures are implemented.

\begin{description}
\item[{\texttt{<vector>}}] dynamic array
\item[{\texttt{<map>}}] dynamic sorted key-value pair
\item[{\texttt{<set>}}] mathematical set
\item[{\texttt{<unordered\_map>}}] hashmap
\item[{\texttt{<unordered\_set>}}] hashset
\item[{\texttt{<queue>}}] priority\_queue, normal queue
\item[{\texttt{<deque>}}] double-linked queue
\item[{\texttt{<stack>}}] stack
\end{description}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline74}]{Algorithms}
 All routines are included in \texttt{<algorithm>}.

\begin{itemize}
\item Non-modifying sequence operations, e.g., \texttt{all\_of}, \texttt{any\_of},
\texttt{count}, \texttt{find}, \texttt{find\_first\_of}, etc.
\item Modifying sequence operations, e.g., \texttt{copy}, \texttt{copy\_if},
\texttt{remove\_if}, \texttt{swap}, \texttt{reverse}, etc.
\item Partitioning operations, e.g., \texttt{partition}, \texttt{stable\_partition}.
\item Sorting operations, e.g., \texttt{sort}, \texttt{is\_sorted}, \texttt{partial\_sort},
\texttt{stable\_sort}, and etc.
\item Binary search operations (on sorted ranges), \texttt{lower\_bound},
\texttt{upper\_bound}, \texttt{binary\_search}, etc.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline75}]{Algorithms Cont'd}
 \begin{itemize}
\item Set operations (on sorted ranges), \texttt{merge}, \texttt{inplace\_merge},
\texttt{set\_difference}, etc.
\item Heap operations, \texttt{is\_heap}, \texttt{make\_heap}, \texttt{push\_heap}, \texttt{pop\_heap},
\texttt{sort\_heap}, etc.
\item Minimum/maximum operations, \texttt{max}, \texttt{min}, \texttt{minmax},
\texttt{lexicographical\_compare}, \texttt{next\_permutation}, etc.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline76}]{Utilities}
 \begin{itemize}
\item Dynamic memory management.  Smart pointers (e.g., \texttt{unique\_ptr},
\texttt{shared\_ptr}), allocators (e.g., \texttt{std::allocator}).
\item Pair and tuples.  \texttt{pair}, \texttt{tuple} and etc.
\item \texttt{bitset}, manipulate bits.
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline77}]{Numerics}
 \begin{itemize}
\item In \texttt{<cmath>}, standard mathematical functions include \texttt{sqrt()},
\texttt{log()}, \texttt{sin()} and etc. for type \texttt{float}, \texttt{double} and \texttt{long
     double}.
\item Complex numbers, in \texttt{<complex>}.
\item Random numbers, in \texttt{<random>}.
\item Numeric limits, in \texttt{<numeric\_limits>}.  E.g.,
\texttt{std::numeric\_limits<int>::max()}.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgheadline78}]{Concurrency}
The standard library directly supports concurrent execution of
multiple threads in a single address space.
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline79}]{Summary}
 \begin{itemize}
\item Core languages features
\item STL libraries
\end{itemize}


For more information about \texttt{C++}.  Online resources include
\begin{itemize}
\item \url{http://cppreference.com}
\item \url{http://www.cplusplus.com/}
\end{itemize}
\end{frame}
\end{document}
