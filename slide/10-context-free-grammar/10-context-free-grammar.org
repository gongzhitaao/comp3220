#+TITLE: Context Free Grammar
#+SETUPFILE: ../slide-setup.org
#+MACRO: G \(\mathcal{G}\)

* Introduction

** Grammar

   - Grammar :: is a certain kind of collection of rules for building
        strings.  Like DFAs, NFAs, and regular expressions, grammars
        are mechanisms for defining languages rigorously.

** Toy English Grammar

   - An article \(A\) can be the word /a/ or /the/.
     \[\begin{aligned}A&\to a\\ A&\to the \end{aligned}\]

   - A noun \(N\) can be the word /dog/, /cat/ or /rat/.  \[N\to dog
     \mid cat \mid rat\]

   - A noun phrase \(P\) is an article followed by a noun.  \[P\to
     AN\]

   - A verb \(V\) can be the word /love/, /hate/ or /eat/.  \[V\to
     love \mid hate \mid eat\]

   - A sentence \(S\) can be a noun phrase, followed by a verb,
     followed by another noun phrase \[S\to PVP\]

** Terminology

   The following defines a grammar {{{G()}}}

   \[\begin{aligned}S&\to PVP\\P&\to AN\\V&\to love \mid hate \mid
   eat\\ A&\to a\mid the\\ N&\to dog\mid cat\mid rat\end{aligned}\]

   - Each rule is called a /production/ or /production rule/.
   - \(X\to Y\) means \(X\) can be substitute by \(Y\).  \(X\to
     Y_1\mid Y_2\) is a compact form of \[\begin{aligned}X&\to
     Y_1\\X&\to Y_2\end{aligned}\]
   - \(S, P, V, A, N\) are /terminals/, /love/, /hate/, /eat/ and etc
     are /non-terminals/.

** Generator

   The grammar is a language /generator/.  Finite automaton is a
   language /recognizer/.

*** Grammar                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}S&\to PVP\\P&\to AN\\V&\to love \mid hate \mid
    eat\\ A&\to a\mid the\\ N&\to dog\mid cat\mid rat\end{aligned}\]

    \(S\) is the /start symbol/.

*** Generates A String                                                :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}\textcolor{red}{S}&\Rightarrow
    \textcolor{red}{P}VP\\&\Rightarrow
    \textcolor{red}{A}NVP\\&\Rightarrow
    the\textcolor{red}{N}VP\\&\Rightarrow
    thecat\textcolor{red}{V}\\&\Rightarrow
    thecateat\textcolor{red}{P}\\&\Rightarrow
    thecateat\textcolor{red}{A}N\\&\Rightarrow
    thecateata\textcolor{red}{N}\\&\Rightarrow
    thecateatarat\end{aligned}\]

** Derivation

*** Generate A String                                                 :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:

    \[\begin{aligned}\textcolor{red}{S}&\Rightarrow
    \textcolor{red}{P}VP\\&\Rightarrow
    \textcolor{red}{A}NVP\\&\Rightarrow
    the\textcolor{red}{N}VP\\&\Rightarrow
    thecat\textcolor{red}{V}\\&\Rightarrow
    thecateat\textcolor{red}{P}\\&\Rightarrow
    thecateat\textcolor{red}{A}N\\&\Rightarrow
    thecateata\textcolor{red}{N}\\&\Rightarrow
    thecateatarat\end{aligned}\]

*** Notes                                                             :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:

    - More one place to apply production rule
    - Leftmost derivation is not required, e.g.,
      - \(\textcolor{red}{P}loveP\Rightarrow ANloveP\)
      - \(Plove\textcolor{red}{P}\Rightarrow PloveAN\)

** Informal Definition

   - Grammar :: is a set of productions of the form \(x\to y\).
     - \(x\) and \(y\) may both contain lowercase and uppercase
       letters.
     - \(x\) cannot be \epsilon, but \(y\) can be \epsilon.
     - One uppercase letter is designated as the /start symbol/,
       usually \(S\) by convention.


   Given a grammar {{{G()}}}, the language it defines is
   \[\mathcal{L}(\mathcal{G}) = \{x\mid x \text{ is generated by }
   \mathcal{G}\}\]

   When a sequence of permissible substitutions starting from \(S\)
   ends in a string of all lowercase, we say /the grammar generates
   that string/.

** Example Grammar

   Given a grammar {{{G()}}}

   \[\begin{aligned}S&\to aS\mid X\\ X&\to bX\mid
   \epsilon\end{aligned}\]

   The language defined by {{{G()}}} is\pause

   \[\mathcal{L}(\mathcal{G}) = \mathcal{L}(a^*b^*)\]

* Grammar

** Formal Definition

   A grammar {{{G()}}} is a 4-tuple

   \[\mathcal{G} = (V, \Sigma, S, P)\]

   - \(V\) is an alphabet, the /non-terminal/ alphabet
   - \(\Sigma\) is another alphabet, the /terminal/ alphabet
   - \(V\bigcap\Sigma = \emptyset\)
   - \(S\in V\) is the start symbol
   - \(P\) is a /finite/ set of productions, each of the form
     \(\alpha\to\beta\),
     - \(\alpha\) is \((V\bigcup\Sigma)^* V (V\bigcup\Sigma)^*\),
       i.e., a string of terminals and non-terminals containing at
       /least one/ non-terminal
     - \(\beta\) is \((V\bigcup\Sigma)^*\), i.e., a string of
       terminals and non-terminals.

** Example Grammar

   \[\begin{aligned}S&\to aS\mid X\\X&\to bX\mid
   \epsilon\end{aligned}\]

   This grammar \(\mathcal{G} = (V, \Sigma, S, P)\) is defined as:

   - \(V = \{S, X\}\)
   - \(\Sigma = \{a, b\}\)
   - \(P = \{S\to aS, S\to X, X\to bX, X\to \epsilon\}\)

** Language Generated by Grammar

   - \(\Rightarrow\) :: \(w\) derives \(z\), denoted as \(w\Rightarrow
        z\), if and only if \(\exists u, x, y, v\in \Sigma\bigcup V\)
        such that \(w = uxv\), \(z = uyv\) and \((x\to y)\in P\)
   - \(\Rightarrow^*\) :: \(w\Rightarrow^* z\) if and only if there is
        a derivation of 0 or more steps that starts with \(w\) and
        ends with \(z\).  Specifically, \alpha is called a /sentential
        form/ iff \(S\Rightarrow^*\alpha\).

   The language generated by a grammar {{{G()}}} is
   \[\mathcal{L}(\mathcal{G}) = \{x\in\Sigma^* \mid S\Rightarrow^*
   x\}\]

** NFA to Grammar
   #+BEGIN_theorem
   There is a grammar for every regular language.
   #+END_theorem

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/nfa-to-grammar.pdf]]
   #+END_CENTER

   The above NFA \(\mathcal{M}\) describes \pause
   \(\colorbox{red!10}{\texttt{a*bc*}}\)

   - For each state, our grammar will have a non-terminal symbol
     (\(S\), \(R\) and \(T\)).
   - The start state \(S\) will be the grammar's start symbol.
   - The grammar will have one production for each transition of the
     NFA, and one for each accepting state

** NFA to Grammar
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/nfa-to-grammar.pdf]]
   #+END_CENTER

   For each possible transition \(Y\in\delta(X,z)\) in the NFA, we
   have a production in our grammar \(X\to zY\).

   #+ATTR_LaTeX: :mode math :environment array
   | \text{Transition of } \mathcal{M} | \text{Production in } \mathcal{G} |
   |-----------------------------------+-----------------------------------|
   | \delta(S,a) = \{S\}               | S\to aS                           |
   | \delta(S,b) = \{R\}               | S\to bR                           |
   | \delta(R,c) = \{R\}               | R\to cR                           |
   | \delta(R,\epsilon) = \{T\}        | R\to T                            |
   \framebreak

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/nfa-to-grammar.pdf]]
   #+END_CENTER

   For each accepting state in the NFA, we have an \epsilon-production
   in our grammar.

   #+ATTR_LaTeX: :mode math :environment array
   | \text{Accepting state of } \mathcal{M} | \text{Production in } \mathcal{G} |
   |----------------------------------------+-----------------------------------|
   | T                                      | T\to\epsilon                      |
   \framebreak

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/nfa-to-grammar.pdf]]
   #+END_CENTER

   \[\begin{aligned}S&\to aS \mid bR\\ R&\to cR \mid T\\ T&\to
   \epsilon\end{aligned}\]

   Given a string \(abc\)
  \begin{alignat*}{4}\mathcal{M}&:\ (S,abc) &&\mapsto (S, bc) &&\mapsto
  (R, c)\ &\mapsto (R, \epsilon) &\mapsto (T, \epsilon)\\
  \mathcal{G}&:\ S &&\Rightarrow aS &&\Rightarrow abR &\Rightarrow abcR
  &\Rightarrow abcT \Rightarrow abc \end{alignat*}

* Context Free Grammar

** Context Free

   We only discuss grammar with production like

   \[S\to Sa\]

   Only a /single non-terminal/ symbol appear at left-hand side of
   each production, which is called context-free grammar (CFG).

   Grammars with production like \(aS\to Sa\) is context-sensitive.

** Formal Definition

   A grammar {{{G()}}} is a 4-tuple

   \[\mathcal{G} = (V, \Sigma, S, P)\]

   - \(V\) is an alphabet, the /non-terminal/ alphabet
   - \(\Sigma\) is another alphabet, the /terminal/ alphabet
   - \(V\bigcap\Sigma = \emptyset\)
   - \(S\in V\) is the start symbol
   - \(P\) is a /finite/ set of productions, each of the form
     \(\alpha\to\beta\),
     - *\(\alpha\) is \(V\), i.e., a single non-terminal*
     - \(\beta\) is \((V\bigcup\Sigma)^*\), i.e., a string of
       terminals and non-terminals.

** Chomsky Hierarchy

   #+ATTR_LaTeX: :width \textwidth
   [[file:img/chomsky-hierarchy.pdf]]

** Revisit \(\{a^nb^n\}\) with NFA

   #+ATTR_BEAMER: :overlay +-
   - \(n\leq 0\) {{{imginline(width=2.3cm,img/try-nfa-ab-0.pdf)}}}
   - \(n\leq 1\) {{{imginline(width=4cm,img/try-nfa-ab-1.pdf)}}}
   - \(n\leq 2\) {{{imginline(width=6cm,img/try-nfa-ab-2.pdf)}}}

** Revisit \(\{a^nb^n\}\) with CFG

   \[S\to aSb \mid \epsilon\]

   - \(\textcolor{red}{S}\Rightarrow ab\)
   - \(\textcolor{red}{S}\Rightarrow a\textcolor{red}{S}b\Rightarrow
     aabb\)
   - \(\textcolor{red}{S}\Rightarrow a\textcolor{red}{S}b\Rightarrow
     aa\textcolor{red}{S}bb\Rightarrow aaabbb\)
   - etc.

** Regular Language to CFG

   If the language is regular, conversion to CFG is easy.
   - construct an NFA, and
   - convert to right-linear grammar (regular grammar)

** Regular Language to CFG Example 0

   \[\begin{aligned}S &\to aR \\ R &\to bR \mid aT \\ T &\to
   \epsilon\end{aligned}\]

   This grammar describes \pause \(\colorbox{red!10}{\texttt{ab*a}}\).

   A corresponding NFA accepts this language. \pause

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/reg-to-nfa.pdf]]
   #+END_CENTER

** Regular Language to CFG Example 1

   \[\mathcal{L} = \{x\in\{0, 1\}^*\mid \text{the number of 0's is
   divisible by 3}\}\]

   \pause

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .6\textwidth
   [[file:img/cons-cfg-0.pdf]]
   #+END_CENTER

   \pause

*** Version 0                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}S &\to 1S \mid 0T \mid \epsilon\\ T &\to 1T \mid
    0U \\ U &\to 1U \mid 0S\end{aligned}\]

    \pause

*** Version 1                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}S &\to T0T0T0S\mid T\\ T &\to 1T \mid
    \epsilon\end{aligned}\]

** Balanced Pairs to CFG

   CFLs often involves balanced pairs.

   - \(\{a^nb^n\}\) every \(a\) paired with \(b\)
   - \(\{xx^R\mid x\in\{a,b\}^*\}\) each \(x\) paired with its mirror
     image \(x^R\)
   - \(\{a^nb^ia^n\mid n\geq 0, i\geq 1\}\) same number of \(a\)'s on
     each side


   To get matching pairs, following recursive production is often used

   \[R\to xRy\]

*** Language                                                          :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    - \(\{a^nb^n\}\)
    - \(\{xx^R\mid x\in\{a,b\}^*\}\)
    - \(\{a^nb^ia^n\mid n\geq 0, i\geq 1\}\)
    - \(\{a^nb^{3n}\}\)

*** CFG                                                               :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    - \(S\to aSb \mid \epsilon\)\pause
    - \(S\to aSa \mid bSb \mid \epsilon\)\pause
    - \(S\to aSa \mid R\), \(R\to bR \mid \epsilon\)\pause
    - \(S\to aSbbb \mid \epsilon\)

** Non-Regular Grammar to NFA

   \[\begin{aligned}S &\to abR \\ R &\to a\end{aligned}\]

   - \(S\to abR\) is equivalent to \(S\to aX, X\to bR\)
   - \(R\to a\) is equivalent to \(R\to aT, T\to \epsilon\)


   \[\begin{aligned}S &\to aX\\ X &\to bR \\ R &\to aT \\ T &\to
   \epsilon \end{aligned}\]

   #+BEGIN_CENTER
   #+ATTR_LaTeX: :width .7\textwidth
   [[file:img/nonreg-to-nfa.pdf]]
   #+END_CENTER

** Grammar Concatenation

   \[L = \{a^nb^nc^md^m\}\]

   - It is easy to write grammars separately
     - \(L_1 = \{a^nb^n\}\): \(S_1\to aS_1b \mid \epsilon\)
     - \(L_2 = \{c^md^m\}\): \(S_2\to cS_2d \mid \epsilon\)
   - Since \(L = L_1L_2\), \(S\to S_1S_2\)

** Grammar Union

   \[L = \{z\in \{a, b\}^*\mid z = xx^R \text{ or } \vert z\vert
   \text{ is odd}\}\]

   - \(L_1 = \{xx^R \mid x\in \{a, b\}^*\}\)

     \[S_1\to aS_1a \mid bS_2b \mid \epsilon\]

   - \(L_2 = \{z\in \{a, b\}^*\mid \vert z\vert \text{ is odd}\}\)

     \[\begin{aligned}S_2 &\to XXS_2 \mid X\\X &\to a\mid
     b\end{aligned}\]

   - Since \(L = L_1\bigcup L_2\), \(S\to S_1\mid S_2\)

* Backus-Naur Form (BNF)

** Introduction

   Backus-Naur Form (BNF) was developed by John Backus and Peter Naur,
   independently from CFG.

   - Every symbol is enclosed by =<>=
   - \(\to\) replace by ~::=~.

   #+BEGIN_SRC bnf
<syntax>     ::= <rule> | <rule> <syntax>
<rule>       ::= <space> "<" <TEXT> ">" <space>
                 "::=" <space> <expression> <line-end>
<space>      ::= " " <space> | ""
<expression> ::= <list> | <list> "|" <expression>
<line-end>   ::= <space> <EOL> | <line-end> <line-end>
<list>       ::= <term> | <term> <space> <list>
<term>       ::= <literal> | "<" <rule-name> ">"
<literal>    ::= "\"" <TEXT> "\"" | "'" <TEXT> "'"
   #+END_SRC

** BNF Notation -- Kleene Closure

   The symbol \(\{ \}\) is used for "zero or more".

   #+BEGIN_SRC bnf
<unsigned> ::= <nonzero> { <digit> }
<digit>    ::= 0 | <nonzero>
<nonzero>  ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
   #+END_SRC

   The \(\{\alpha\}\) is equivalent to \(A\to A\alpha\mid\alpha\).

   #+BEGIN_SRC bnf
<unsigned> ::= <nonzero> <more>
<more>     ::= <more> <digit> | <digit>
<digit>    ::= 0 | <nonzero>
<nonzero>  ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
   #+END_SRC

** BNF Notation -- Optional

   The symbol \([\ ]\) is used for optional items.

   #+BEGIN_SRC bnf
<stmt> ::= if <cond> then <stmt> [else <stmt>]
   #+END_SRC

   The \([\alpha]\) is equivalent to \(A\to \alpha \mid \epsilon\).

   #+BEGIN_SRC bnf
<stmt> ::= if <cond> then <stmt> <else>
<else> ::= else <stmt> | ""
   #+END_SRC

** BNF Notation -- Miscellaneous

   | Usage            | Notation   |
   |------------------+------------|
   | termination      | ;          |
   | alternation      | \(\mid\)   |
   | optional         | \([\ ]\)   |
   | repetition       | \(\{\ \}\) |
   | grouping         | \((\ )\)   |
   | Terminal string  | " " or ' ' |

   See C99 YACC/Bison grammar
   http://www.quut.com/c/ANSI-C-grammar-y-2011.html

** BNF Example
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

   #+BEGIN_SRC bnf
<exp> ::= <exp> - <exp>
        | <exp> * <exp>
        | <exp> = <exp>
        | <exp> < <exp>
        | (<exp>)
        | a | b | c
   #+END_SRC

   Some strings generated by this grammar

   - =a < b=
   - =(a - (b * c))=
   - =a = c=
   - =a * b = c=


   \framebreak

   #+BEGIN_SRC bnf
 <binary> ::= <digit> | <binary> <digit>
 <digit>  ::= 0 | 1
   #+END_SRC

   This grammar generates strings with 0 and 1.

* Parse Tree

** Left/Right-most Derivation

   \[S\to SS \mid (S) \mid ()\]

   This is balanced-parentheses grammar.

   Given a string =(())()=, we have multiple ways to generate it.

   - Leftmost derivation \(S\Rightarrow
     \textcolor{red}{S}S\Rightarrow(\textcolor{red}{S})S\Rightarrow
     (())S\Rightarrow (())()\)
   - Rightmost derivation \(S\Rightarrow
     S\textcolor{red}{S}\Rightarrow S()\Rightarrow(S)()\Rightarrow(())()\)

** Parse Tree

   \[S\Rightarrow
   \textcolor{red}{S}S\Rightarrow(\textcolor{red}{S})S\Rightarrow
   (())S\Rightarrow (())()\]

*** Demo                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:

    #+BEGIN_CENTER
    [[file:img/parse-tree-demo.pdf]]
    #+END_CENTER

*** Terminology                                                       :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:

    - Parse trees :: are trees labeled by symbols of a particular
         grammar.
    - Leaves :: are labeled by a terminal or \epsilon.
    - Interior nodes :: are labeled by a variable (i.e.,
         non-terminals), the children of which are labeled by the right
         side of the production or the parent.
    - Root :: is labeled by the start symbol.

** Yield of Parse Tree

   The concatenation of the labels of the leaves in left-to-right
   order, i.e., pre-order traversal, is the /yield/ of the parse tree.

   The yield of {{{imginline(width=.25\textwidth,img/parse-tree-demo.pdf)}}}
   is =(())()=.

** Ambiguous Grammar

   A grammar is /ambiguous/ if there is a string in the language that
   is the yield of more than one distinct parse trees.

   #+BEGIN_theorem
   For every parse tree, there is a unique leftmost, and a unique
   rightmost derivation.
   #+END_theorem

   A grammar is /ambiguous/ if

   - the grammar generates a sentence with more than one leftmost
     derivation or
   - the grammar generates a sentence with more than one rightmost
     derivation.

** Ambiguous Grammar Example

   Two ways to generate =()()()= from grammar \(S\to SS \mid (S) \mid
   ()\).

*** =()()()= Leftmost                                                 :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}S &\Rightarrow\textcolor{red}{S}S\Rightarrow
    \textcolor{red}{S}SS\Rightarrow ()\textcolor{red}{S}S
    \\&\Rightarrow ()()S\Rightarrow ()()()\end{aligned}\]

    #+BEGIN_CENTER
    #+ATTR_LaTeX: :width .5\textwidth
    [[file:img/ambiguous-0.pdf]]
    #+END_CENTER

*** =()()()= Version 2                                                :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}S &\Rightarrow S\textcolor{red}{S}\Rightarrow
    SS\textcolor{red}S\Rightarrow S\textcolor{red}{S}() \\&\Rightarrow
    S()()\Rightarrow ()()()\end{aligned}\]

    #+BEGIN_CENTER
    #+ATTR_LaTeX: :width .5\textwidth
    [[file:img/ambiguous-1.pdf]]
    #+END_CENTER

** Why Ambiguous?

   Ambiguity is a /property/ of grammars, NOT languages.

   - \(S\to SS \mid (S) \mid ()\) is ambiguous.
   - \(\begin{aligned}S&\to (RS \mid \epsilon\\ R &\to ) \mid (RR
     \end{aligned}\) \(R\) generates strings that have one more
     right ')'

** Ambiguity Good or Bad?

   - Bad.  It leaves meaning of some programs ill-defined since we
     cannot decide its syntactical structure uniquely.
   - Good.  Ambiguous grammars are often used in LR parsing because of
     simplicity.

*** Grammar 0                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}E \to & E + E\\ \mid& E * E\\ \mid& (E) \mid
    \epsilon\end{aligned}\]

*** Grammar 1                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    \[\begin{aligned}E &\to E + T \mid T\\ T &\to T * F\mid
    F\\ F &\to (E) \mid \text{ id} \end{aligned}\]

** Solution to Ambiguity

   1. Disambiguate the grammar, i.e., rewrite the grammar.
   2. In practice use disambiguating declarations.

** Disambiguate the Grammar 0

   \[\begin{aligned}S \to& \text{ if } E \text{ then } S\\
   \mid & \text{ if } E \text{ then } S \text{ else } S\end{aligned}\]

   This is /the dangling else/ problem.

   =if= \(E_1\) =then if= \(E_2\) =then= \(S_1\) else \(S_2\)

*** Dangling Else 0                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    [[file:img/dangling-else-0.pdf]]

*** Dangling Else 1                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    [[file:img/dangling-else-1.pdf]]

** Disambiguate the Grammar 1

   Disambiguating Rule: Match each =else= with the closest unmatched
   =then=.  To incorporate the rule, we need to distinguish between
   matched \(M\) and unmatched \(U\).

   \[\begin{aligned}S \to\ & M\mid U\\ M\to\ & \text{ if } E \text{
   then } M \text{ else } M\\ U\to\ &\text{ if } E \text{ then } S
   \\\mid\ &\text{ if } E \text{ then } M \text{ else } U
   \end{aligned}\]

** Disambiguating Declarations

   In practice, instead of rewriting the grammar,
   1. use the more natural (ambiguous) grammar
   2. along with /disambiguating declarations/


   Most tools (e.g., YACC) allow /precedence/ and /associativity/
   declaration for terminals

** Associativity

   Productions that are left (right)-recursive force evaluation in
   left-to-right (right-to-left) order, i.e., left (right)
   associativity.

   \[\begin{aligned}S\to\ & E\\ \mid\ & S + E\\ \mid\ & S * E\\ E\to\
   & a\mid b\mid c\mid S\end{aligned}\]

   Parse \(a + b * c\) and \(a * b + c\).

** Precedence

   Precedence is introduced by adding new non-terminal symbols.

   - Symbols with lowest precedence closest to the start symbol.
   - Lower symbol in the parse tree has higher precedence.

*** Grammar                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    Given following grammar

    \[\begin{aligned}E &\to E + T \mid T\\ T &\to T * F\mid F\\ F &\to
     (E) \mid a \end{aligned}\]

     Consider the string \(a + a * a\).

*** Parse Tree                                                        :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.35
    :END:

    [[file:img/precedence.pdf]]

** Inherent Ambiguity

   It would be nice if for every ambiguous grammar, there were some
   way to fix the ambiguity.  However, some CFL's are /inherently
   ambiguous/.

   \[\{0^i1^j2^k\mid i = j \text{ or } j = k\}\]

*** Grammar                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    One possible grammar

    \[\begin{aligned}S&\to AB\mid CD\\ A&\to 0A1\mid 01\\ B&\to 2B\mid
    2 \\ C&\to 0C\mid 0 \\D &\to 1D2\mid 12\end{aligned}\]

*** Derivation                                                        :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    Consider the string 012

    - \(S\Rightarrow AB\Rightarrow 01 B\Rightarrow 012\)
    - \(S\Rightarrow CD\Rightarrow 0D \Rightarrow 012\)

** Ambiguity Summary

   - Ambiguity is good since it simplifies the grammar
   - Ambiguity is bad since it is ambiguous


   As for ambiguity solution

   - We have no general techniques to handle ambiguity
   - Impossible to remove ambiguity automatically

** LL/LR Parser

   - LL :: *L*-eft-to-right scan, *L*-eftmost derivation
   - LR :: *L*-eft-to-right scan, *R*-ightmost derivation


   - As for more in depth review, see [[http://stackoverflow.com/questions/5975741/what-is-the-difference-between-ll-and-lr-parsing][difference between LL and LR]]
   - As for the comparison, [[http://programmers.stackexchange.com/questions/19541/what-are-the-main-advantages-and-disadvantages-of-ll-and-lr-parsing][pros and cons of LL and LR]]

* Summary

** Limitation?

   \[L = \{a^nb^n\}\]

   \[S\to aSb \mid \epsilon\]

   \[L = \{a^nb^nc^n\}\]

   \[S\to\dots\]

* COMMENT Dummy

#  LocalWords:  SETUPFILE mathcal DFAs NFAs PVP BMCOL textcolor NVP
#  LocalWords:  Rightarrow thecat thecateat thecateata thecateatarat
#  LocalWords:  loveP ANloveP Plove PloveAN tuple emptyset bigcup aS
#  LocalWords:  bX uyv cR bigcap img leq imginline nb CFG aSb aabb aa
#  LocalWords:  bb aaabbb NFA aR bR aT colorbox texttt ATTR LaTeX pre
#  LocalWords:  textwidth nc md cS bS Naur BNF sentential iff SRC bnf
#  LocalWords:  EOL stmt cond disambiguating associativity Lexeme
#  LocalWords:  Lexemes
