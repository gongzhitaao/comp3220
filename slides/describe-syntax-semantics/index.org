#+TITLE: PPL -- Describing Syntax & Semantics
#+OPTIONS: ^:nil tex:dvipng
#+SETUPFILE: ../setup.org
#+MACRO: color @@html: <span style="color: $1">$2</span>@@

* Introduction

  - Syntax :: the form or structure of the expressions, statements,
       and program units.
  - Semantics :: the meaning of the expressions, statements, and
       program units.


  Syntax + Semantics = Language Definition

* Problem Overview

  - Sentence :: A string of characters over pre-defined alphabet.
  - Language :: A set of sentences.
  - Lexeme :: The lowest level syntactic unit of a language.
  - Token :: A category of lexemes.

** Example

   #+BEGIN_SRC C
index = 2 * count + 17;
   #+END_SRC

   #+ATTR_HTML: :style font-size:80%
   | Lexemes | Tokens               |
   |---------+----------------------|
   | index   | identifier           |
   | =       | equal sign, operator |
   | 2       | integer, literal     |
   | *       | multiply, operator   |
   | count   | identifier           |
   | +       | plus, operator       |
   | 17      | integer, literal     |
   | ;       | semicolon            |

** Language Recognizer

   If R, when fed any string of characters over \Sigma, accepts it
   only if it is in L, then R is a description of L.

   Pushdown Automatas (PDAs) is a recognizer.

   #+ATTR_HTML: :height 210px
   #+CAPTION: Language Recognizer/Syntax Analyzer
   [[./img/recognizer.svg]]

** Language Generator

   Generator is like a box of /chocolates/ (strings).  You never know
   what you're gonna get.

   A generator provides a construction description.  Context Free
   Grammers (CFGs) is a generator.

   #+ATTR_HTML: :height 200px
   #+CAPTION: Language Generator
   [[./img/generator.svg]]

* Describing Syntax

  Grammer is a formal /language generation/ mechanisms.

  For programming languages:
  - /Context Free Grammar/ (CFG) or
  - /Backus-Naur Form/ (BNF)

** Context Free Grammar

   Developed by Noam Chomsky in the mid-1950s

   #+ATTR_HTML: :height 360px
   #+CAPTION: Chomsky Hierarchy
   [[./img/chomsky-hierarchy.svg]]

** BNF

   BNF is a *metalanguage*.

   #+BEGIN_SRC bnf
<syntax>     ::= <rule> | <rule> <syntax>
<rule>       ::= <space> "<" <TEXT> ">" <space> "::=" <space> <expression> <line-end>
<space>      ::= " " <space> | ""
<expression> ::= <list> | <list> "|" <expression>
<line-end>   ::= <space> <EOL> | <line-end> <line-end>
<list>       ::= <term> | <term> <space> <list>
<term>       ::= <literal> | "<" <rule-name> ">"
<literal>    ::= "\"" <TEXT> "\"" | "'" <TEXT> "'"
   #+END_SRC

*** Terminology

    #+BEGIN_SRC bnf
<line-end> ::= <space> <EOL> | <line-end> <line-end>
    #+END_SRC

   - {{{color(#ff2929,&lt;NAME&gt;)}}} is /nonterminal symbol/ or
     /nonterminal/ or an /abstraction/.
   - {{{color(#fce94f,&lt;NAME&gt;)}}} is /terminal symbol/ or
     /terminal/.
   - First nonterminal is referred to as /start symbol/.
   - The whole line is a /rule/ or /production/.
   - A BNF description, or grammar, is a collection of rules.


   Terminals are tokens and lexemes.

*** BNF Rules

    One rule may have more than one /distinct/ definitions.

    They could be written separately

    #+BEGIN_SRC bnf
<if-stmt> ::= if ( <logic-expr> ) <stmt>
<if-stmt> ::= if ( <logic-expr> ) <stmt> else <stmt>
    #+END_SRC

    or together joined by "|", logic OR.

    #+BEGIN_SRC bnf
<if-stmt> ::= if ( <logic-expr> ) <stmt>
            | if ( <logic-expr> ) <stmt> else <stmt>
    #+END_SRC

*** BNF Ellipsis

    How to describe list of variable lenght, like =1,2,...=?

    Use *recursion*.

    #+BEGIN_SRC bnf
<list> ::= <IDENTIFIER> | <IDENTIFIER> "," <list>
    #+END_SRC

*** Derivation

    A derivation is
    - repeated application of rules,
    - starting with the start symbol and
    - ending with a sentence (all terminals).


    Each string in derivation is called a /sentential form/.

    BNF is a generator, so there may be infinite sentences.


*** Example Derivation

    A grammar for a bogus language

    #+BEGIN_SRC bnf
<integer> ::= <digit> | <integer> <digit>
<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    #+END_SRC

    One possible /leftmost/ derivation is

    #+BEGIN_SRC bnf
<integer> ⇨ <integer> <digit> ⇨ <digit> <digit> ⇨ 3 <digit> ⇨ 32
    #+END_SRC

    One possible /rightmost/ derivation is

    #+BEGIN_SRC bnf
<integer> ⇨ <integer> <digit> ⇨ <integer> 2 ⇨ <digit> 2 ⇨ 32
    #+END_SRC

** Parse Tree

   - Parse trees :: They are trees labeled by symbols of a particular
        grammar.
   - Leaves :: Labeled by a terminal.
   - Interior nodes :: Labeled by a variable, the children of which
        are labeled by the right side of production.
   - Root :: Labeled by start symbol.

*** Example Parse Tree

    #+BEGIN_SRC bnf
S ::= SS | (S) | ()
    #+END_SRC

    #+ATTR_HTML: :width 500px
    [[./img/parse-tree-ex1.svg]]

    A preorder traverse of the parse tree is called the /yield/ of the
    parse.

    The yield of tree on the left is =(())()=.

*** Ambiguous Grammars

    A grammar is /ambiguous/ if there is a string in the language that
    is the yield of more than one distict parse tree.

    In other words, if and only if it generates a sentential form that
    has two or more distinct parse trees.

    - if the grammar generates a sentence with more than one leftmost
      derivation or
    - of the grammar generates a sentence with more than one rightmost
      derivation.

*** Example Ambiguous Grammar

    Given a grammar

    #+BEGIN_SRC bnf
S ::= SS | (S) | ()
    #+END_SRC

    For the sentence =()()()=

    #+ATTR_HTML: :width 440px
    [[./img/ambiguous-grammar-a.svg]]

    #+ATTR_HTML: :width 440px
    [[./img/ambiguous-grammar-b.svg]]

*** Who's fault?

    Ambiguity is a /property/ of grammars, NOT languages.

    For balanced parentheses language, an alternative non-ambiguous
    grammar exsits:

    #+BEGIN_SRC bnf
<B> ::= (RB) | ε
<R> ::= ) | (RR
    #+END_SRC

*** Inherent Ambiguity

    Context free languages (CFL) are generated by CFG.

    Unambiguous CFLs are a proper subset of all CFLs, there are
    /inherently ambiguous/ CFLs.

    Exmaple is

    #+ATTR_HTML: :height 160px
    [[./img/inherently-ambiguous-ex.svg]]

*** Operator Associativity

    It may be expressed in grammar, if needed.

    #+BEGIN_SRC bnf
<expr> ::= <expr> "+" <expr> | <ID> # ambiguous
<expr> ::= <expr> "+" <ID> | <ID>   # umambiguous
    #+END_SRC

*** Operator Precedence

    #+BEGIN_SRC bnf
<assign> ::= <id> = <expr>
<id>     ::= A | B | C
<expr>   ::= <id> "+" <expr> | <id> * <expr> | ( <expr> ) | <id>
    #+END_SRC

    Can be changed to

    #+BEGIN_SRC bnf
<assign> ::= <id> = <expr>
<id>     ::= A | B | C
<expr>   ::= <expr> "+" <term> | <term>
<term>   ::= <term> "*" <factor> | <factor>
<factor> ::= ( <expr> ) | <id>
    #+END_SRC

    Lower tokens in the parse tree always have higher /precedence/.

** Extended BNF

   - DOES NOT enhance the descriptive power of BNF.
   - ONLY increases its /readability/ and /writability/.


*** Extensions

    - =[]= :: /Optional/ parts are placed in brackets.
    - =()= :: /Alternative/ parts of areplaced inside parentheses and
         separated via logic OR, "|".
    - ={}= :: Repetitions (0 or more) are placed inside braces.
    - ={}+= :: Repetitions (1 or more)

*** Example EBNF

    The following BNF description of =<term>=

    #+BEGIN_SRC bnf
<term> ::= <term> "*" <factor>
         | <term> "/" <factor>
         | <term> "%" <factor>
    #+END_SRC

    could be described in EBNF

    #+BEGIN_SRC bnf
<term> ::= <term> ( "*" | "/" | "%" ) <factor>
    #+END_SRC

** YACC

   Given a CFG (a generator), the langauge recognizer can be
   consructed automatically.  One of the most famous one is Yet
   Another Compiler-Compiler (YACC).

   Demo: [[https://zaach.github.io/jison/demos/calc/][Jison]]

* Attribute Grammers

* Describing Semantics
