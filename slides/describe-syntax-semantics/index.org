#+TITLE: PPL -- Describing Syntax & Semantics
#+OPTIONS: ^:nil
#+SETUPFILE: ../setup.org
#+MACRO: color @@html: <span style="color: $1">$2</span>@@

* Introduction

  - Syntax :: the form or structure of the expressions, statements,
       and program units.
  - Semantics :: the meaning of the expressions, statements, and
       program units.


  Syntax + Semantics = Language Definition

* Problem Overview

  - Sentence :: A string of characters over pre-defined alphabet.
  - Language :: A set of sentences.
  - Lexeme :: The lowest level syntactic unit of a language.
  - Token :: A category of lexemes.

** Example

   #+BEGIN_SRC C
index = 2 * count + 17;
   #+END_SRC

   #+ATTR_HTML: :style font-size:80%
   | Lexemes | Tokens               |
   |---------+----------------------|
   | index   | identifier           |
   | =       | equal sign, operator |
   | 2       | integer, literal     |
   | *       | multiply, operator   |
   | count   | identifier           |
   | +       | plus, operator       |
   | 17      | integer, literal     |
   | ;       | semicolon            |

** Language Recognizer

   If R, when fed any string of characters over \Sigma, accepts it
   only if it is in L, then R is a description of L.

   Pushdown Automatas (PDAs) is a recognizer.

   #+ATTR_HTML: :height 210px
   #+CAPTION: Language Recognizer/Syntax Analyzer
   [[./img/recognizer.svg]]

** Language Generator

   Generator is like a box of /chocolates/ (strings).  You never know
   what you're gonna get.

   A generator provides a construction description.  Context Free
   Grammers (CFGs) is a generator.

   #+ATTR_HTML: :height 200px
   #+CAPTION: Language Generator
   [[./img/generator.svg]]

* Describing Syntax

  Grammer is a formal /language generation/ mechanisms.

  For programming languages:
  - /Context Free Grammar/ (CFG) or
  - /Backus-Naur Form/ (BNF)

** Context Free Grammar

   Developed by Noam Chomsky in the mid-1950s

   #+ATTR_HTML: :height 360px
   #+CAPTION: Chomsky Hierarchy
   [[./img/chomsky-hierarchy.svg]]

** Formal Definition

   A Context-free grammar =G= is defined by a 4-tuple

   #+ATTR_HTML: :height 120px
   [[./img/cfg-def.svg]]

   - =V= is a finite set of nonterminals and variables
   - \Sigma is a finite set of terminals, disjoint from =V=
   - =R= is rules set and
   - =S= is the start symbol.

** BNF

   BNF is a *metalanguage*.

   #+BEGIN_SRC bnf
<syntax>     ::= <rule> | <rule> <syntax>
<rule>       ::= <space> "<" <TEXT> ">" <space> "::=" <space> <expression> <line-end>
<space>      ::= " " <space> | ""
<expression> ::= <list> | <list> "|" <expression>
<line-end>   ::= <space> <EOL> | <line-end> <line-end>
<list>       ::= <term> | <term> <space> <list>
<term>       ::= <literal> | "<" <rule-name> ">"
<literal>    ::= "\"" <TEXT> "\"" | "'" <TEXT> "'"
   #+END_SRC

*** Terminology

    #+BEGIN_SRC bnf
<line-end> ::= <space> <EOL> | <line-end> <line-end>
    #+END_SRC

   - {{{color(#ff2929,&lt;NAME&gt;)}}} is /nonterminal symbol/ or
     /nonterminal/ or an /abstraction/.
   - {{{color(#fce94f,&lt;NAME&gt;)}}} is /terminal symbol/ or
     /terminal/.
   - First nonterminal is referred to as /start symbol/.
   - The whole line is a /rule/ or /production/.
   - A BNF description, or grammar, is a collection of rules.


   Terminals are tokens and lexemes.

*** BNF Rules

    One rule may have more than one /distinct/ definitions.

    They could be written separately

    #+BEGIN_SRC bnf
<if-stmt> ::= if ( <logic-expr> ) <stmt>
<if-stmt> ::= if ( <logic-expr> ) <stmt> else <stmt>
    #+END_SRC

    or together joined by "|", logic OR.

    #+BEGIN_SRC bnf
<if-stmt> ::= if ( <logic-expr> ) <stmt>
            | if ( <logic-expr> ) <stmt> else <stmt>
    #+END_SRC

*** BNF Ellipsis

    How to describe list of variable lenght, like =1,2,...=?

    Use *recursion*.

    #+BEGIN_SRC bnf
<list> ::= <IDENTIFIER> | <IDENTIFIER> "," <list>
    #+END_SRC

*** Derivation

    A derivation is
    - repeated application of rules,
    - starting with the start symbol and
    - ending with a sentence (all terminals).


    Each string in derivation is called a /sentential form/.

    BNF is a generator, so there may be infinite sentences.


*** Example Derivation

    A grammar for a bogus language

    #+BEGIN_SRC bnf
<integer> ::= <digit> | <integer> <digit>
<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
    #+END_SRC

    One possible /leftmost/ derivation is

    #+BEGIN_SRC bnf
<integer> ⇨ <integer> <digit> ⇨ <digit> <digit> ⇨ 3 <digit> ⇨ 32
    #+END_SRC

    One possible /rightmost/ derivation is

    #+BEGIN_SRC bnf
<integer> ⇨ <integer> <digit> ⇨ <integer> 2 ⇨ <digit> 2 ⇨ 32
    #+END_SRC

** Parse Tree

   - Parse trees :: They are trees labeled by symbols of a particular
        grammar.
   - Leaves :: Labeled by a terminal.
   - Interior nodes :: Labeled by a variable, the children of which
        are labeled by the right side of production.
   - Root :: Labeled by start symbol.

*** Example Parse Tree

    #+BEGIN_SRC bnf
S ::= SS | (S) | ()
    #+END_SRC

    #+ATTR_HTML: :width 500px
    [[./img/parse-tree-ex1.svg]]

    A preorder traverse of the parse tree is called the /yield/ of the
    parse.

    The yield of tree on the left is =(())()=.

*** Ambiguous Grammars

    A grammar is /ambiguous/ if there is a string in the language that
    is the yield of more than one distict parse tree.

    In other words, if and only if it generates a sentential form that
    has two or more distinct parse trees.

    - if the grammar generates a sentence with more than one leftmost
      derivation or
    - of the grammar generates a sentence with more than one rightmost
      derivation.

*** Example Ambiguous Grammar

    Given a grammar

    #+BEGIN_SRC bnf
S ::= SS | (S) | ()
    #+END_SRC

    For the sentence =()()()=

    #+ATTR_HTML: :width 440px
    [[./img/ambiguous-grammar-a.svg]]

    #+ATTR_HTML: :width 440px
    [[./img/ambiguous-grammar-b.svg]]

*** Who's fault?

    Ambiguity is a /property/ of grammars, NOT languages.

    For balanced parentheses language, an alternative non-ambiguous
    grammar exsits:

    #+BEGIN_SRC bnf
<B> ::= (RB) | ε
<R> ::= ) | (RR
    #+END_SRC

*** Inherent Ambiguity

    Context free languages (CFL) are generated by CFG.

    Unambiguous CFLs are a proper subset of all CFLs, there are
    /inherently ambiguous/ CFLs.

    Exmaple is

    #+ATTR_HTML: :height 160px
    [[./img/inherently-ambiguous-ex.svg]]

*** Operator Associativity

    It may be expressed in grammar, if needed.

    #+BEGIN_SRC bnf
<expr> ::= <expr> "+" <expr> | <ID> # ambiguous
<expr> ::= <expr> "+" <ID> | <ID>   # umambiguous
    #+END_SRC

*** Operator Precedence

    #+BEGIN_SRC bnf
<assign> ::= <id> = <expr>
<id>     ::= A | B | C
<expr>   ::= <id> "+" <expr> | <id> * <expr> | ( <expr> ) | <id>
    #+END_SRC

    Can be changed to

    #+BEGIN_SRC bnf
<assign> ::= <id> = <expr>
<id>     ::= A | B | C
<expr>   ::= <expr> "+" <term> | <term>
<term>   ::= <term> "*" <factor> | <factor>
<factor> ::= ( <expr> ) | <id>
    #+END_SRC

    Lower tokens in the parse tree always have higher /precedence/.

** Extended BNF

   - DOES NOT enhance the descriptive power of BNF.
   - ONLY increases its /readability/ and /writability/.


*** Extensions

    - =[]= :: /Optional/ parts are placed in brackets.
    - =()= :: /Alternative/ parts of areplaced inside parentheses and
         separated via logic OR, "|".
    - ={}= :: Repetitions (0 or more) are placed inside braces.
    - ={}+= :: Repetitions (1 or more)

*** Example EBNF

    The following BNF description of =<term>=

    #+BEGIN_SRC bnf
<term> ::= <term> "*" <factor>
         | <term> "/" <factor>
         | <term> "%" <factor>
    #+END_SRC

    could be described in EBNF

    #+BEGIN_SRC bnf
<term> ::= <term> ( "*" | "/" | "%" ) <factor>
    #+END_SRC

** YACC

   Given a CFG (a generator), the langauge recognizer can be
   consructed automatically.  One of the most famous one is Yet
   Another Compiler-Compiler (YACC).

   Demo: [[https://zaach.github.io/jison/demos/calc/][Jison]]

** Limitations

   - No representing semantics.  E.g.,
     + Variable must be declared before being used.
     + Type checking: Use of variable should conform to its type.
   - Only generate parse tree.
     + But I want to generate assembly code from the source.

* Describing Semantics

  - /Syntax/ concerns the form of a valid program
  - /Semantics/ concerns the meaning


** Two phases

  - Static Semantic ::
    - Enforced by compiler at compile time (thus static)
    - Implemented in semantic analysis phase
    - CFGs is not powerful enough
    - E.g., type checking, appropriate use of identifiers.
  - Dynamic Semantic ::
    - Enforced by code generated by compiler
    - Check occurs at run time, exception raised if fails
    - E.g., array bounds, artihmetic error (dividing zero),
      uninitialized variables, etc.

** Static Semantics

   The static semantics is
   - indirectly related to the meaning of programs during execution.
   - It has to do with the legal forms of programs (syntax rather than
     semantics).

*** Definition

    #+ATTR_HTML: :height 60px
    [[./img/cfg-def.svg]]

    - Each grammar symbol =X= is associated with a set of attributes
      =A(X)=, which consists of two disjoint sets
      - =S(X)= the synthesized attributes
      - =I(X)= the inherited attributes
    - Each rule has a set of functions that define certain attributes
      of the nonterminals in the rule.
    - Each rule has a (possibly empty) set of /predicates/ to check for
      attribute consistency.

*** Intrinsic Attributes

    - Synthesized attributes of leaf nodes
    - values are determined outside the parse tree
    - Like initial values or conditions

*** Example Attribute Grammar

    #+BEGIN_SRC bnf
<stmt> ::= <var> "=" <expr>  SR: (expr.et = var.at)
<expr> ::= <var>1 "+" <var>2 SR: (expr.at = if (var1.at = int) and
                                               (var2.at = int)
                                              int
                                            else
                                              real)
                              P: (expr.at == expr.et)
<expr> ::= <var>             SR: (expr.at = var.at)
                              P: (expr.at == expr.et)
<var>  ::= A | B | C         SR: (var.at = LOOKUP(var.string))
    #+END_SRC

    =at= stands for =actual_type= and =et= stands for =expected_type=.

*** Example Parse Tree

    Given sentence =A = A + B=.  We have a parse tree

    #+ATTR_HTML: :width 600px
    [[./img/parse-tree-ag-ex1.svg]]

*** Example Compute Attributes

    Flow of attributes.

    #+ATTR_HTML: :width 672px
    [[./img/parse-tree-ag-ex2.svg]]

    Example: [[http://zaach.github.io/jison/demos/calc/][Jison]]

** Dynamic Semantics

   NO universally accepted notation or approach has been devised for
   /dynamic semantics/.

   - Programmers need to know statements meaning.
   - Compiler writers must know exactly what language constructs mean
     to design them correctly.
   - Correctness of proof would be possible
   - Auto generating compilers
   - Designers could detect ambiguities and inconsistencies


*** Methods

    - Operational Semantics
    - Denotational Semantics
    - Axiomatic Semantics


*** Operational Semantics

    Describe the meaning of a statement or program by specifying the
    effects of running it on a machine.

    We need a "virtual computer" to interprete the intermediate code.

    - Good if kept simple and informal
    - Extremely complex if used formally


*** Usage

    - Language manuals and textbooks
    - Teaching programming languages


    - Natural operational semantics
    - Structural operational semantics


*** Denotational Semantics

    Based on recursive function theory.

    Howto:

    - Define a mathematical object for each language entity
    - Define a function that maps instances of the language entities
      onto instances of the corresponding mathematical objects.


*** Mapping Function

    - Syntactic Domain (domain) :: Collection of values that are
         legitimate parameters to the function.
    - Semantic Domain (range) :: Collection of objects to which the
         parameters are mapped.


*** Exmaple Denotational Semantics 0

    Given the following grammar

    #+BEGIN_SRC bnf
<bin> ::= "0" | "1" | <bin> "0" | <bin> "1"
    #+END_SRC

    #+ATTR_HTML: :width 400px
    [[./img/parse-tree-ds-ex1.svg]]

    For the sentence =110=, we have the parse tree on the left.

*** Example Denotaional Semantics 2

    - Syntactic domain :: The set of all character string
         representations of binary numbers.
    - Semantic domain :: the set of nonnegative decimal numbers,
         symbolized by N.


*** Example Denotaional Semantics 3

    The mapping function

    - F("0") = 0
    - F("1") = 1
    - F(<bin> "0") = 2 * F(<bin>)
    - F(<bin> "1") = 2 * F(<bin>) + 1


*** Example Denotaional Semantics 4

    A parse tree with denoted objects for =110=.

    #+ATTR_HTML: :width 400px
    [[./img/parse-tree-ds-ex2.svg]]


*** Axiomatic Semantics

    - Based on math logic, predicate calculus
    - For proof of correctness
    - The meaning of a program is based on /relationships/ among
      program variables and constants,


    #+BEGIN_EXAMPLE
    {P} statement {Q}
    #+END_EXAMPLE

    =P= and =Q= are called /predicates/ or /assertions/.  And =P= is
    precondition and =Q= postcondition.

    And the above is called a /Hoare triple/.

*** Example Axiomatics Semantics

    A assignment statement with a postcondition

    #+BEGIN_EXAMPLE
    sum = 2 * x + 1 { sum > 1 }
    #+END_EXAMPLE

    - One possible precondition may be ={x > 10}=
    - But the *weakest precondition* is ={x > 0}=.

    It is the least restrictive precondition that will guarantee the
    validity of the associated postcondition.

*** Notes

    We always follow /assignment axiom scheme/.

    - precondition is the target
    - we are given the postcondition
    - replace all free occurences of the LHS with RHS
    - then we get the precondition


    Nonsence example

    #+BEGIN_EXAMPLE
{ x = 5 } x := 3 { 3 = 5 }
    #+END_EXAMPLE

*** Uniqueness

    A given postcondition =Q= uniquely determines the precondition
    =P=.  Inverse is /not/ true.

    - ={0 ≤ y*y ∧ y*y ≤ 9}  x = y * y  {0 ≤ x ∧ x ≤ 9}=
    - ={0 ≤ y*y ∧ y*y ≤ 9}  x = y * y  {0 ≤ x ∧ y*y ≤ 9}=
    - ={0 ≤ y*y ∧ y*y ≤ 9}  x = y * y  {0 ≤ y*y ∧ x ≤ 9}=
    - ={0 ≤ y*y ∧ y*y ≤ 9}  x = y * y  {0 ≤ y*y ∧ y*y ≤ 9}=


*** Inference Rule

    If =S1, S2, ..., Sn= are true, then the truth of =S= can be
    inferred.

    An *axiom* is a logic statment assumed to be true.  So it is an
    inference rule /without an antecedent/

    #+ATTR_HTML: :height 100px
    [[./img/inference-rule.svg]]


*** Example Inference Rule

    which means that =P= is computed as =Q= with all instances of =x=
    replaced by =E= (without side effects).

    #+ATTR_HTML: :height 80px
    [[./img/assignment-axiom.svg]]

*** Example Axiomatics Semantics

    Suppose we have the following statements

    #+BEGIN_EXAMPLE
x = x + y - 3 {x > 10}
    #+END_EXAMPLE

    The weakest precondition is

    #+BEGIN_EXAMPLE
y = 13 - x
    #+END_EXAMPLE

*** Proof of Correctness

    #+ATTR_HTML: :height 80px
    [[./img/proof-correctness.svg]]

    #+BEGIN_EXAMPLE
{x > 3} x = x - 3 {x > 0}
    #+END_EXAMPLE

    Using the above axiom on

    #+BEGIN_EXAMPLE
x = x - 3 {x > 0}
    #+END_EXAMPLE

    produces ={x > 3}=, which is the given precondition.

*** Proof of Correctness

    Suppose we have

    #+BEGIN_EXAMPLE
{x > 5} x = x - 3 {x > 0}
    #+END_EXAMPLE

    We need to use the /rule of consequence/

    #+ATTR_HTML: :height 120px
    [[./img/consequence-rule.svg]]

*** Sequence Inference

    #+ATTR_HTML: :height 300px
    [[./img/sequence-inference.svg]]


*** Loops

    #+BEGIN_EXAMPLE
{P} while B do S end {Q}
    #+END_EXAMPLE

    #+ATTR_HTML: :height 100px
    [[./img/loop-inference.svg]]

    - =P= implies =I=
    - ={I} B {I}=
    - ={I AND B} S {I}=
    - ={I AND (NOT B)}= implies Q
    - The loop terminates


*** Loop Invariant

    /Loop invariant/ is a condition that is necessarily true
    immediately *before* and immediately *after* *each* iteration of
    the loop.

    We use simple =while= loop as an example.

*** Exmaple Loop Invariant

    #+BEGIN_SRC C++
{P} while (B) { S } {Q}
    #+END_SRC

    Where

    - =P= is the precondition
    - =Q= is the postcondition, and
    - =I= denotes the loop invariant as usual.

    We also assume that =B= has no side effects.  In =while (++i) { }=
    where =B= is =++i= is not what we want.

*** Loop Invariant Critical Location

    #+ATTR_HTML: :width 800px
    [[./img/loop-invariant.svg]]

*** Notes on Loop Invariant

    - Invariant itself is not useful, if chosen improperly.
    - Usually, invariant is chosen as what we want to proof.


*** Example 1 Loop Invariants

    Insertion sort algorithm from CLRS (Introduction to Algorithm).

    #+BEGIN_EXAMPLE
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        // Insert A[j] into the sorted sequence A[1..j-1]
        i = j - 1
        while i > 0 and A[i] > key
            do A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
    #+END_EXAMPLE

    Loop invariant is chose as

    #+BEGIN_EXAMPLE
At the start of each iteration of the for loop of lines the subarray
A[1..j-1] consists of the elements originally in A[1..j-1], but in
sorted order.
    #+END_EXAMPLE

*** Example 2 Loop Invariants

    Suppose we have a sum function

    #+BEGIN_SRC C++
int s = 0;
for (int i = 0; i < a.size(); i++) {
  // s is the sum of the first i array elements
  // s == a[0] + .. + a[i-1]
  s = s + a[i];
}
    #+END_SRC

    What might be a good loop invariant?

*** Example 2 Loop Invariants Cont'd

    One possible loop invariant:

    #+BEGIN_EXAMPLE
s holds the sum of a[0..i] (inclusive and exclusive)
    #+END_EXAMPLE

    Proof:

    - Initialization
    - Maintenace
    - Termination


*** Evaluation of Axiomatic Semantics

    - Developing axioms or inference rules for all of the statements
      is difficult
    - Good for correctness proof
    - Programmers and compiler writers not care

* Summary

  - BNF and CFG
  - Static semantics with attribute Grammar
  - Dynamic Semantics with operational, denotational and axiomatics.
