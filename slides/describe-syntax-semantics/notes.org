#+TITLE: Notes

* Problem Overview

  The /lexemes/ of a programming language include its numeric
  literals, operators, and special words, among others.  One can think
  of programs as /strings of lexemes/ rather than of characters.

* CFG vs RegEx

  Example: RE to CFG

We will build a CFG G for the RE (0|1)*111.

First the operands:

      <0> --> 0
      <1> --> 1

Now the innermost operator, union:

      <R1> --> <0> | <1>

Now the closure operator:

      <R2> --> <R1> <R2> | epsilon

Now the concatenation operators:

      <RE> --> R2 R3 R4 R5
      <R3> --> <1>
      <R4> --> <1>
      <R5> --> <1>

The final grammar G is:

      <RE> --> R2 R3 R4 R5
      <R2> --> <R1> <R2> | epsilon
      <R1> --> <0> | <1>
      <R3> --> <1>
      <R4> --> <1>
      <R5> --> <1>
      <0> --> 0
      <1> --> 1

A CFG with no Corresponding RE

Recall that FA cannot count. Thus, no FA can recognize the language {0^n 1^n|n>=1} (i.e., the set of strings containing one or more zeros followed by an equal number of ones).

Assume such an FA exists, and it has N states. What happens when the input string has N+1 zeros in it, followed by N+1 ones?

Since the FA only has N states, we must visit some state sT twice on seeing N+1 zeros.
The FA cannot know whether we are entering sT for the first time, when we've seen i < N zeros, or the second time, when we've seen j > i zeros.
There must be a path from sT to an accepting state, since the input string is in the language.
The FA will accept an input string without an equal number of zeros and ones, since i != j, and there is a path to an accepting state from sT on the remaining input.
This language is generated by the following CFG:

<S> --> 0 <S> 1
<S> --> 01
We can prove that this grammar generates the language by induction on n, the number of zeros and ones in the string.

For the basis step, n = 1, and the string is 01. This string is generated by applying the second production once.
For the inductive step, assume we can generate O^n1^n. The last production applied must have been production 2, so the string must have been 0^(n-1)<S>1^(n-1). If we apply production 1 and then production 2, we get 0^n<S>1^n, and then 0^(n+1)1^(n+1). Thus, we can generate all strings of the form {0^n 1^n|n>=1}.
Since we can only apply production 1 some number of times followed by production 2, these are the only strings generated by the grammar.
